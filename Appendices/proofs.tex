\chapter{Metatheory Proofs}

\section{Sound Erasure Proofs}
\begin{lemma}{\scshape{Sound Static Typing Erasure}}

    If $C \vdash e^{*} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
    \\ then $\erase[C]{C} \vdash \erase[e^{*}]{e^{*}} : \erase[tfi]{ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2}$
\end{lemma}
\begin{proof}
    \label{proof:statictypingerasure}
    We proceed by induction over typing derivations. Most proof cases are omitted as they are simple, but we provide a few to give an idea of what the proofs look like.
    Intuitively, we want to show that erasing the typing derivation produces a valid \wasm typing derivation.

    For most of the cases, the sequence of instructions $e^{*}$ contains only a single instruction $e_2$, so we elide the step of turning $\erase[e^{*}]{e^{*}}$ into $\erase[e^{*}]{e_2}$.

    \begin{itemize}
        \item Case: $C \vdash t.binop : {\begin{stackTL}\ti{t}{a_1}\;\ti{t}{a_2};l_1;\phi_1 \\ \rightarrow \ti{t}{a_3};l_1;\phi_1,\ti{t}{a_3},(= a_3\; (binop\;a_1\;a_2))\end{stackTL}}$

            We want to show that
            $$\erase[C]{C}\;
            {\begin{stackTL}
                \vdash \erase[e^{*}]{t.binop}
                \\: erase_{tfi}(
                {\begin{stackTL}
                    \ti{t}{a_1}\;\ti{t}{a_2};l_1;\phi_1
                    \\ \rightarrow \ti{t}{a_3};l_1;\phi_1,\ti{t}{a_3},(= a_3\; (binop\;a_1\;a_2)))
                \end{stackTL}}
            \end{stackTL}}$$

            By the definition of $erase_e$, we want to show that $\erase[C]{C}\vdash t.binop : t\;t \rightarrow t$ is valid in \wasm.

            Trivially, we have $\erase[C]{C}\vdash t.binop : t\;t \rightarrow t$ by \refrule{Wasm-Binop}, since \refrule{Wasm-Binop} works under any module type context.

        \item Case: $C \vdash \<block>\;
        {\begin{stackTL}
            \ti{t_1}{a_1}^{*};l_1;\phi_1
            \\ \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2
            \\ e^{*} \<end> :
            {\begin{stackTL}
                \ti{t_1}{a_1}^{*};l_1;\phi_1
                \\ \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2
            \end{stackTL}}
        \end{stackTL}}$

            We want to show that $$\erase[C]{C} \vdash erase_e(\<block>\;
            {\begin{stackTL}
                \ti{t_1}{a_1}^{*};l_1;\phi_1
                \\ \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2
                \\ e^{*} \<end> :
                {\begin{stackTL}
                    \ti{t_1}{a_1}^{*};l_1;\phi_1
                    \\ \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2)
                \end{stackTL}}
            \end{stackTL}}$$

            By the definition of $erase_e$ and $erase_{tfi}$ (we also perform the step of erasing indexed function types here to avoid an extra step), we want to show that $\erase[C]{C} \vdash \<wblock>\; t_1^{*} \rightarrow t_2^{*} e^{*} \<wend> : t_1^{*} \rightarrow t_2^{*}$ is a valid \wasm judgment.

            This proof is slightly more involved, since the derivation for this rule includes a premise that $$C,\text{label}(\ti{t_2}{a_2}^{*};l_2;\phi_2) \vdash e^{*} : \ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2$$

            By the inductive hypothesis for the well-typedness of $e^{*}$, we have that $$\erase[C]{C,\text{label}(\ti{t_2}{a_2}^{*};l_2;\phi_2)}\;
            {\begin{stackTL}
                \vdash \erase[e^{*}]{e^{*}}
                \\: erase_{tfi}(
                {\begin{stackTL}
                    \ti{t_1}{a_1}^{*};l_1;\phi_1
                    \\ \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2)
                \end{stackTL}}
            \end{stackTL}}$$

            Then we have $\erase[C]{C},\text{label}(t_2^{*}) \vdash \erase[e^{*}]{e^{*}} : t_1^{*}\rightarrow t_2^{*}$ by definition of $erase_C$ and $erase_{tfi}$.

            Now that we have satisfied the premise, $$\erase[C]{C} \vdash \<wblock>\; t_1^{*} \rightarrow t_2^{*} e^{*} \<wend> : t_1^{*} \rightarrow t_2^{*}$$ by \refrule{Wasm-Block}.

        \item Case: $C \vdash \<br>\; i : \ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2$

            We want to show that $$\erase[C]{C}\;
            {\begin{stackTL}
                    \vdash erase_e(\<br> i)\;
                    \\ : \erase[tfi]{\ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2}
            \end{stackTL}}$$

            We have to reason about $\erase[C]{C}$ because the typing judgment relies on the label stack from $C$.

            From $C \vdash \<br>\; i : \ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2$, we have that $C_\text{label}(i)=\ti{t_1}{a_1}^{*};l_1;\phi_1$, since it is a premise.

            Then ${\erase[C]{C}}_\text{label}(i) = t_1^{*}$, by the definition of $erase_C$.

            $$\erase[C]{C}\;
            {\begin{stackTL}
                    \vdash erase_e(\<br> i)\;
                    \\ : {\begin{stackTL}
                        \erase[tfi]{\ti{t_1}{a_1}^{*};l_1;\phi_1
                        \\ \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2}
                    \end{stackTL}}
            \end{stackTL}} \\
            = \erase[C]{C} \vdash \<br> i : t_1^{*} \rightarrow t_2^{*}$$

            Recall that ${\erase[C]{C}}_\text{label}(i) = t_1^{*} \rightarrow t_2^{*}$, then $\erase[C]{C} \vdash \<br> i : t_1^{*} \rightarrow t_2^{*}$ by \refrule{Wasm-Br}.

        \item Case: $C \vdash \<call>\; i : \ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2$

            We want to show that $$\erase[C]{C}\;
            {\begin{stackTL}
                    \vdash erase_e(\<call> i)\;
                    \\ : \erase[tfi]{\ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2}
            \end{stackTL}}$$

            We again have to reason about $\erase[C]{C}$ because the typing judgment relies on the function type from $C$.

            From $C \vdash \<call>\; i : \ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2$, we have that $C_\text{func}(i)=\ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2$, since it is a premise.

            Then, ${\erase[C]{C}}_\text{func}(i) = \erase[tfi]{\ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2} = t_1^{*} \rightarrow t_2^{*}$, by the definition of $erase_C$.

            $$\erase[C]{C}\;
            {\begin{stackTL}
                    \vdash erase_e(\<call> i)\;
                    \\ : {\begin{stackTL}
                        \erase[tfi]{\ti{t_1}{a_1}^{*};l_1;\phi_1
                        \\ \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2}
                    \end{stackTL}}
            \end{stackTL}} \\
            = \erase[C]{C} \vdash \<call> i : t_1^{*} \rightarrow t_2^{*}$$

            Recall that ${\erase[C]{C}}_\text{func}(i) = t_1^{*} \rightarrow t_2^{*}$.

            Then $\erase[C]{C} \vdash \<call> i : t_1^{*} \rightarrow t_2^{*}$ by \refrule{Wasm-Call}.

        \item Case: $C \vdash \<setlocal>\; i : \ti{t}{a};l_1;\phi_1 \rightarrow \epsilon;l_1[i := a];\phi_1$

            We want to show that $$\erase[C]{C}\;
            {\begin{stackTL}
                    \vdash erase_e(\<setlocal> i)\;
                    \\ : \erase[tfi]{\ti{t}{a};l_1;\phi_1 \rightarrow \epsilon;l_1[i := a];\phi_1}
            \end{stackTL}}$$

            We again have to reason about $\erase[C]{C}$ because the typing judgment relies on the local variable types from $C$.

            From $C \vdash \<setlocal>\; i : \ti{t}{a};l_1;\phi_1 \rightarrow \epsilon;l_1[i := a];\phi_1$, we have that $C_\text{local}(i)=t$, since it is a premise.

            Then, we have that ${\erase[C]{C}}_\text{local}(i) = t$, by the definition of $erase_C$.

            $$\erase[C]{C}\;
            {\begin{stackTL}
                    \vdash erase_e(\<setlocal> i)\;
                    \\ : {\begin{stackTL}
                        \erase[tfi]{\ti{t}{a}^{*};l_1;\phi_1
                        \\ \rightarrow \epsilon;l_1[i := a];\phi_1}
                    \end{stackTL}}
            \end{stackTL}} \\
            = \erase[C]{C} \vdash \<setlocal> i : t \rightarrow \epsilon$$

            Recall that ${\erase[C]{C}}_\text{local}(i) = t \rightarrow \epsilon$, then $\erase[C]{C} \vdash \<setlocal> i : t \rightarrow \epsilon$ by \refrule{Wasm-Set-Local}.

        \item Case: $C \vdash e_1^{*}\;e_2 : \ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_2}{a_2};l_2;\phi_2$

            We want to show that $$\erase[C]{C}\;
            {\begin{stackTL}
                    \vdash erase_e(e_1^{*}\;e_2)\;
                    \\ : \erase[tfi]{\ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_2}{a_2};l_2;\phi_2}
            \end{stackTL}}$$

            For this typing rule, we must invoke the inductive hypothesis twice: one on the sequence $e_1^{*}$ and once on the instruction $e_2$. Then we must show that we can compose the erased subsequence together to get a well-typed sequence.

            We know that $C \vdash e_1^{*} : \ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_3}{a_3};l_3;\phi_3$ and that $C \vdash e_2 : \ti{t_3}{a_3}^{*};l_3;\phi_3 \rightarrow \ti{t_2}{a_2};l_2;\phi_2$ because they are premieses of \refrule{Composition} which we have assumed to hold.

            $\erase[C]{C} \vdash \erase[e^{*}]{e_1^{*}} : \erase[tfi]{\ti{t_1}{a_1}^{*};l_1;\phi_1 \rightarrow \ti{t_3}{a_3};l_3;\phi_3}$ by the inductive hypothesis on $e_1^{*}$.

            $\erase[C]{C} \vdash \erase[e^{*}]{e_1^{*}} : t_1^{*} \rightarrow t_3^{*}$ by definition of $erase_{tfi}$.

            $\erase[C]{C} \vdash \erase[e^{*}]{e_2} : \erase[tfi]{\ti{t_3}{a_3}^{*};l_3;\phi_3 \rightarrow \ti{t_2}{a_2};l_2;\phi_2}$, by the inductive hypothesis on $e_2$.

            $\erase[C]{C} \vdash \erase[e^{*}]{e_2^{*}} : t_3^{*} \rightarrow t_2^{*}$ by definition of $erase_{tfi}$.

            $$\erase[C]{C}\;
                {\begin{stackTL}
                        \vdash erase_{e^{*}}(e_1^{*}\;e_2)\;
                        \\ : {\begin{stackTL}
                            \erase[tfi]{\ti{t_1}{a_1}^{*};l_1;\phi_1
                            \\ \rightarrow \ti{t_2}{a_2};l_2;\phi_2}
                        \end{stackTL}}
                \end{stackTL}} \\
                = \erase[C]{C}
                {\begin{stackTL}
                    \vdash\;
                    {\begin{stackTL}
                        \erase[e^{*}]{e_1^{*}}
                        \\ \erase[e^{*}]{e_2}
                    \end{stackTL}}
                    \\: t_1^{*} \rightarrow t_2^{*}
                \end{stackTL}}$$

            Recall that we have $\erase[C]{C} \vdash \erase[e^{*}]{e_1^{*}} : t_1^{*} \rightarrow t_3^{*}$ and that $\erase[C]{C} \vdash \erase[e^{*}]{e_2^{*}} : t_3^{*} \rightarrow t_2^{*}$ by definition of $erase_{tfi}$.

            Then, $\erase[C]{C} \; \vdash\; \erase[e^{*}]{e_1^{*}}\; \erase[e^{*}]{e_2}: t_1^{*} \rightarrow t_2^{*}$ by \refrule{Wasm-Composition}.

    \end{itemize}
\end{proof}

\begin{lemma}{\scshape{Sound Admin Typing Erasure}}

    If $S;C \vdash e^{*} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
    \\ then $\erase[S]{S};\erase[C]{C} \vdash \erase[e^{*}]{e^{*}} : \erase[tfi]{ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2}$
\end{lemma}
\begin{proof}
    \label{proof:admintypingerasure}

    We proceed by induction over typing rules.
    In addition to the prior cases from \reflemma{Sound Static Typing Erasure}, which trivially still hold since the value of $S$ does not matter to those rules, we add proves for a few administrative typing rules, which may refer to $S$.
    Again, several proof cases are omitted as they are simple.

    \begin{itemize}
        \item $S;C \vdash \<label>_n \{ e_0^{*} \}\; e^{*} \<end> : \epsilon;l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{n};l_2;\phi_2$

        We must show that
        $$\erase[S]{S};\erase[C]{C} {\begin{stackTL}
            \vdash \erase[e^{*}]{e_0^{*}}
            \\: \erase[tfi]{\ti{t_3}{a_3}^{*};l_3;\phi_3 \rightarrow \ti{t_2}{a_2}^{n};l_2;\phi_2}
        \end{stackTL}}$$
        and
        $$\erase[S]{S};erase_C(C{\begin{stackTL}
            ,\text{label}(\ti{t_3}{a_3}^{*};l_3;\phi_3))
            \\ \vdash \erase[e^{*}]{e^{*}}
            \\ : \erase[tfi]{\epsilon;l_1;\phi_1 \rightarrow \ti{t_3}{a_3}^{*};l_3;\phi_3}
        \end{stackTL}}$$
        as they are the premises of typechecking a label block in \wasm.

        We have that $S;C \vdash e_0^{*} : \ti{t_3}{a_3}^{*};l_3;\phi_3 \rightarrow \ti{t_2}{a_2}^{n};l_2;\phi_2$ since it is a premise of \refrule{Label} which we have assumed to hold.

        Then, by the inductive hypothesis for the stored instructions $e_0^{*}$ being well typed, we have that

        $$\erase[S]{S};\erase[C]{C} {\begin{stackTL}
            \vdash \erase[e^{*}]{e_0^{*}}
            \\: \erase[tfi]{\ti{t_3}{a_3}^{*};l_3;\phi_3 \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2}
        \end{stackTL}}$$

        $S;C,\text{label}(\ti{t_3}{a_3}^{*};l_3;\phi_3)) \vdash e^{*} : \epsilon;l_1;\phi_1 \rightarrow \ti{t_3}{a_3}^{*};l_3;\phi_3$, because it is a premise of \refrule{Label} which we have assumed to hold.

        By the inductive hypothesis for the body $e^{*}$ being well typed, we have that

        $$\erase[S]{S};erase_C(C{\begin{stackTL}
            ,\text{label}(\ti{t_3}{a_3}^{*};l_3;\phi_3))
            \\ \vdash \erase[e^{*}]{e^{*}}
            \\ : \erase[tfi]{\epsilon;l_1;\phi_1 \rightarrow \ti{t_3}{a_3}^{*};l_3;\phi_3}
        \end{stackTL}}$$

        \item $S;C \vdash \<local>_n \{ i;v^{*} \}\; e^{*} \<end> : \epsilon;l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{n};l_2;\phi_2$

        The premise of this rule relies on \refrule{Code} with a non-empty return postcondition, which we have not yet proved sound erasure for, so instead we must derive \refrule{Code} for the erased program.

        Thus, we must show that $(\vdash v : t_v)^{*}$ and
        $$\erase[S]{S};erase_C(
        {\begin{stackTL}
            S_\text{inst}(i),\text{local } t_v^{*},\text{ return}(\ti{t_2}{a_2}^{n};l_2;\phi_2))
            \\ \vdash \erase[e^{*}]{e^{*}}
            \\: \erase[tfi]{\epsilon;l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{n};l_2;\phi_2}
        \end{stackTL}}$$

        We have \refrule{Code} as a premise of \refrule{Local}, which we have assumed to hold.

        Therefore, $(\vdash v : t_v)^{*}$ trivially, since neither values nor primitive types are affected by erasure.

        We also know that
        $$S;S_\text{inst}(i),\text{local } t_v^{*},\text{ return}(\ti{t_2}{a_2}^{n};l_2;\phi_2)) {\begin{stackTL}\vdash e^{*} \<end> \\: \epsilon;l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{n};l_2;\phi_2\end{stackTL}}$$

        Therefore, by the inductive hypothesis of the well-typedness of $e^{*}$, we have that
        $$\erase[S]{S};erase_C(
        {\begin{stackTL}
            S_\text{inst}(i),\text{local } t_v^{*},\text{ return}(\ti{t_2}{a_2}^{n};l_2;\phi_2))
            \\ \vdash \erase[e^{*}]{e^{*}}
            \\: \erase[tfi]{\epsilon;l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{n};l_2;\phi_2}
        \end{stackTL}}$$
    \end{itemize}
\end{proof}

\section{Subject Reduction Lemmas and Proofs}
\label{sec:subreduxproof}

\begin{lemma}{\scshape{Inversion}}
    \begin{enumerate}
        %% const
        \item If $S;C \vdash t.\<const> c : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_2^{*} = ti_1^{*}\;\ti{t}{a}$, $l_1 = l_2$,
        and $\phi_1,\ti{t}{a},(= a \; \ti{t}{c}) \implies \phi_2$.

        %% binop
        \item If $S;C \vdash t.binop : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti^{*} \; \ti{t}{a_1} \; \ti{t}{a_2}$, $ti_2^{*} = ti^{*} \; \ti{t}{a_3}$, $l_1 = l_2$,
        and $\phi_1,\ti{t}{a_3},(= a_3\;(binop\;a_1\;a_2)) \implies \phi_2$.

        %% testop
        \item If $S;C \vdash t.testop : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti^{*} \; \ti{t}{a_1}$, $ti_2^{*} = ti^{*} \; \ti{\<ithreetwo>}{a_2}$, $l_1 = l_2$,
        and $\phi_1,\ti{\<ithreetwo>}{a_2},(= a_2\;(testop\;a_1)) \implies \phi_2$.

        %% relop
        \item If $S;C \vdash t.relop : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti^{*} \; \ti{t}{a_1} \; \ti{t}{a_2}$, $ti_2^{*} = ti^{*} \; \ti{\<ithreetwo>}{a_3}$, $l_1 = l_2$,
        and $\phi_1,\ti{\<ithreetwo>}{a_3},(= a_3\;(relop\;a_1\;a_2)) \implies \phi_2$.

        %% nop
        \item If $S;C \vdash \<nop> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_2^{*}$, $l_1=l_2$, and $\phi_1 \implies \phi_2$.

        %% drop
        \item If $S;C \vdash \<drop> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_0^{*}\;\ti{t}{a}$, $ti_2^{*} = ti_0^{*}$, $l_1=l_2$, and $\phi_1 \implies \phi_2$.

        %% select
        \item If $S;C \vdash \<select> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        \\ then $ti_1^{*} = ti_0^{*}\;\ti{t}{a_1}\;\ti{t}{a_2}\;\ti{\<ithreetwo>}{a_3}$, $ti_2^{*} = ti_0^{*};\ti{t}{a}$, $l_1=l_2$, and $\phi_1,\ti{t}{a},(\text{if} (= a_3\; \ti{\<ithreetwo>}{0})\; (= a_1\; a)\; (= a_2\; a)) \implies \phi_2$.

        %% block
        \item If $S;C \vdash \<block>\; {\begin{stackTL}(ti_3^{*};l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4)\\ e^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2\end{stackTL}}$
        \\ then $ti_1^{*} = ti_0^{*}\; ti_3^{*}$, $ti_2^{*}=ti_0^{*}\; ti_4^m$, $l_1=l_3$, $l_2=l_4$, $\phi_1 \implies \phi_3$, $\phi_4 \implies \phi_2$, and $S;C,\text{label}(ti_4^m;l_4;\phi_4) \vdash e^{*} : ti_3^{*};l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4$.

        %% loop
        \item If $S;C \vdash \<loop>\; (ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4)\; e^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_0^{*}\; ti_3^n$, $ti_2^{*}=ti_0^{*}\; ti_4^m$, $l_1=l_3$, $l_2=l_4$, $\phi_1 \implies \phi_3$, $\phi_4 \implies \phi_2$, and $S;C,\text{label}(ti_3^n;l_3;\phi_3) \vdash e^{*} : ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4$.

        %% if
        \item If $S;C \vdash \<if>\; (ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4)\; e_1^{*} \<else> e_2^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_0^{*}\; ti_3^n\; \ti{\<ithreetwo>}{a}$, $ti_2^{*}=ti_0^{*}\; ti_4^m$, $l_1=l_3$, $l_2=l_4$, $\phi_1 \implies \phi_3$, $\phi_4 \implies \phi_2$, $S;C,\text{label}(ti_4^m;l_4;\phi_4) \vdash e_1^{*} : ti_3^n;l_3;\phi_3,\neg(= a\; \ti{\<ithreetwo>}{0}) \rightarrow ti_4^m;l_4;\phi_4$, and $S;C,\text{label}(ti_4^m;l_4;\phi_4) \vdash e_2^{*} : ti_3^n;l_3;\phi_3,(= a\; \ti{\<ithreetwo>}{0}) \rightarrow ti_4^m;l_4;\phi_4$.

        %% label
        \item If $S;C \vdash \<label>_n \{ e_0^{*} \} e^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_2^{*} = ti_1^{*} \; ti^{*}$,
        $S;C \vdash e_0^{*} : ti_3^{*};l_3;\phi_3 \rightarrow ti^{*};l_2;\phi_2$,
        and $S;C,\text{label } (ti_3^{*};l_3;\phi_3) \vdash e^{*} : \epsilon;l_1;\phi_1 \rightarrow ti^{*};l_2;\phi_2$

        %% br
        \item If $S;C \vdash \<br> i : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_3^{*}\;ti^{*}$, $C_\text{label}(i) = ti^{*};l_1;\phi_3$,
        and $\phi_1 \implies \phi_3$.

        %% br_if
        \item If $S;C \vdash \<brif> i : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_2^{*} \; \ti{\<ithreetwo>}{a}$, $l_1 = l_2$, $C_\text{label}(i) = ti_2^{*};l_1;\phi_3,\neg(= a\; \ti{\<ithreetwo>}{0})$,
        $\phi_1 \implies \phi_3$,
        and $\phi_1,(= a\; \ti{\<ithreetwo>}{0}) \implies \phi_2$.

        %% br_table
        \item If $S;C \vdash \<brtable> i^{+} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_2^{*} \; \ti{\<ithreetwo>}{a}$, $l_1 = l_2$, $C_\text{label}(i) = ti_2^{*};l_1;\phi_3$,
        $\phi_1 \implies \phi_3$,
        and $\phi_1 \implies \phi_2$.

        %% call j
        \item If $S;C \vdash \<call> i : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_0^{*} \; ti_3^{*}$, $ti_2^{*} = ti_0^{*} \; ti_4^{*}$, $C_\text{func}(j)=ti_3^{*};l_3;\phi_3 \rightarrow ti_4^{*};l_4;\phi_4$, $l_2=l_1$, $\phi_1 \implies \phi_3$, and $\phi_3,\phi_4 \implies \phi_2$.

        %% call_indirect
        \item If $S;C \vdash \<callindirect> ti_3^{*};l_3;\phi_3 \rightarrow ti_4^{*};l_4;\phi_4 : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_0^{*} \; ti_3^{*}$, $ti_2^{*} = ti_0^{*} \; ti_4^{*}$, $l_2=l_1$, $\phi_1 \implies \phi_3$, and $\phi_3,\phi_4 \implies \phi_2$.

        %% call cl
        \item If $S;C \vdash \<call> cl : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_2^{*}=ti_1^{*}\;ti_4^m$, $l_2=l_1$, $\phi_1 \implies \phi_3$, $\phi_4 \implies \phi_2$, and $S\vdash cl : \epsilon;ti_3^{n}\;\ti{t}{a}^{n};\phi_3,\ti{t}{a}^k,(= a \;\ti{t}{0})^k \rightarrow ti_4^{m};l_4;\phi_4$

        %% local
        \item If $S;C \vdash \<local>_n \{ i;v_l^{*} \} \; e^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_2^{*} = ti_1^{*} \; ti^n$, $l_1 = l_2$,
        $S;(ti^n;l_3;\phi_3) \vdash_i v_l^{*};e^{*} : ti^n;l_3;\phi_3$,
        and $\phi_1,\phi_3 \implies \phi_2$.

        %% return
        \item If $S;C \vdash \<return> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_3^{*}\;ti^{*}$, $l_1 = l_3$, $C_\text{return} = ti^{*};l_3;\phi_3$,
        and $\phi_1 \implies \phi_3$.

        %% get-local
        \item If $S;C \vdash \<getlocal> i : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_2^{*} = ti_1^{*} \; \ti{t}{a}$, $l_1 = l_2$, $l_1(i) = \ti{t}{a}$,
        and $\phi_1,\ti{t}{a_2},(= a_2\;a) \implies \phi_2$.

        %% set-local
        \item If $S;C \vdash \<setlocal> i : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_2^{*} \; \ti{t}{a}$, $l_2 = l_1[i := \ti{t}{a}]$, $C_\text{local}(i) = t$,
        and $\phi_1 \implies \phi_2$.

        %% tee-local
        \item If $S;C \vdash \<teelocal> i : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti^{*} \; \ti{t}{a}$, $ti_2^{*} = ti^{*} \; \ti{t}{a_2}$, $l_2 = l_1[i := \ti{t}{a}]$, $C_\text{local}(i) = t$,
        and $\phi_1,\ti{t}{a_2},(= a_2\;a) \implies \phi_2$.

        %% get-global
        \item If $S;C \vdash \<getglobal> i : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_2^{*} = ti_1^{*} \; \ti{t}{a}$, $l_1 = l_2$, $C_\text{global}(i) = \text{mut}^{?} \; t$,
        and $\phi_1,\ti{t}{a} \implies \phi_2$.

        %% set-global
        \item If $S;C \vdash \<setglobal> i : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_2^{*} \; \ti{t}{a}$, $l_1 = l_2$, $C_\text{global}(i) = \text{mut} \; t$,
        and $\phi_1 \implies \phi_2$.

        %% mem-load
        \item If $S;C \vdash t.\<load> (tp\_sx)^{?}\; align\; o : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti^{*} \; \ti{\<ithreetwo>}{a_1}$, $ti_2^{*} = ti^{*} \; \ti{t}{a_2}$, $l_1 = l_2$,
        $C_\text{memory} = n$, $2^{align} \leq (|tp| <)^{?} |t|$, and $\phi_1,\ti{t}{a_2} \implies \phi_2$.

        %% mem-store
        \item If $S;C \vdash t.\<store> tp^{?}\; align\; o : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti_2^{*} \; \ti{\<ithreetwo>}{a_1} \; \ti{t}{a_2}$, $l_1 = l_2$, $C_\text{memory} = n$,
        $2^{align} \leq (|tp| <)^{?} |t|$, and $\phi_1 \implies \phi_2$.

        %% current-memory
        \item If $S;C \vdash \<currentmemory> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        \\ then $ti_2^{*} = ti_1^{*} \; \ti{\<ithreetwo>}{a}$, $l_1 = l_2$, $C_\text{memory} = n$,
        and $\phi_1,\ti{\<ithreetwo>}{a} \implies \phi_2$.

        %% grow-memory
        \item If $S;C \vdash \<growmemory> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        then $ti_1^{*} = ti^{*} \; \ti{\<ithreetwo>}{a_1}$, $ti_2^{*} = ti^{*} \; \ti{\<ithreetwo>}{a_2}$, $l_1 = l_2$, $C_\text{memory} = n$,
        and $\phi_1,\ti{\<ithreetwo>}{a_2} \implies \phi_2$.

        %% composition
        \item If $S;C \vdash e_1^{*} \; e_2 : ti_1^{*};l_1;\phi_1 \rightarrow ti_3^{*};l_3;\phi_3$,
        then $S;C \vdash e_1^{*} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
        and $S;C \vdash e_2 : ti_2^{*};l_2;\phi_2 \rightarrow ti_3^{*};l_3;\phi_3$.

        \thought{This relies on a bit of a non-obvious idea that even if the precondition is changed through subtyping, the subtyping can be deferred until a later composition.}

        \thought{This also relies on the idea that even if subtyping appears in the derivation tree, it can equivalently be applied on the premises of the composition.}
    \end{enumerate}
\end{lemma}
\begin{proof}
    Proof omitted, but follows from induction over typing derivations.
\end{proof}

\begin{lemma}{\scshape{Subject Reduction for Code}}

    If $S;(ti;l;\phi)^{?} \vdash v^{*}; e^{*} : ti;l;\phi$,
    $\vdash s : S$, (we omit this on rules that do not use the store)
    and $s;v^{*};e^{*} \hookrightarrow s';v'^{*};e'^{*}$,
    then $S;(ti;l;\phi)^{?} \vdash v'^{*}; e'^{*} : ti;l;\phi$,
    and $\vdash s' : S$ (we omit this on rules that do not change the store)
\end{lemma}
\begin{proof}
    \label{proof:subreduxcode}
    By induction on reduction.

    \begin{itemize}
        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_i v_1^j\;(t.\<const> c)\;v_2^k;\<getlocal> j : ti^{*};l;\phi$
        \\ $\land$ $v_1^j\;(t.\<const> c)\;v_2^k;\<getlocal> j \hookrightarrow (t.\<const> c)$

            We want to show that $S;(ti;l;\phi)^{?} \vdash_i v_1^j\;(t.\<const> c)\;v_2^k; (t.\<const> c) : ti^{*};l;\phi$.

            We know $\vdash (t.\<const> c) : \ti{t}{a};\circ,\ti{t}{a},(= a\;\ti{t}{c})$ and $S;C \vdash \<getlocal> j : \epsilon;l_1;\phi_1^j,(\ti{t}{a},(= a\;\ti{t}{c})),\phi_2^k \rightarrow ti^{*};l;\phi$,
            because they are premises of \refrule{Code} that we have assumed to hold.

            By \reflemma{Inversion} on \refrule{Get-Local},
            $ti^{*} = \ti{t}{a_2}$, $l_1 = l$, and $\phi_1^j,(\ti{t}{a},(= a\;\ti{t}{c})),\phi_2^k,\ti{t}{a_2},(= a_2\;a) \implies \phi$.

            Now we will reconstruct the same type for $v_1^j\;(t.\<const> c)\;v_2^k; (t.\<const> c)$.

            We have $S;S_\text{inst}(i) \vdash (t.\<const> c) : \epsilon;l;\phi_1^j,(\ti{t}{a},(= a\;\ti{t}{c})),\phi_2^k \rightarrow \ti{t}{a_2};l;\phi_1^j,(\ti{t}{a},(= a\;\ti{t}{c})),\phi_2^k,\ti{t}{a_2},(= a_2\;\ti{t}{c})$ by \refrule{Const}.

            Further, $(\ti{t}{a},(= a\;\ti{t}{c})),\ti{t}{a_2},(= a_2\;\ti{t}{c}) \implies (\ti{t}{a},(= a\;\ti{t}{c})),\ti{t}{a_2},(= a_2\;a)$ by $\implies$.

            Then, $S;S_\text{inst}(i) \vdash (t.\<const> c) : \epsilon;l;\phi_1^j,(\ti{t}{a},(= a\;\ti{t}{c})),\phi_2^k \rightarrow \ti{t}{a_2};l;\phi$ by \refrule{Subtyping}.

            Therefore, $S;(ti^{*};l;\phi)^{?} \vdash_i v_1^j\;(t.\<const> c)\;v_2^k; (t.\<const> c) : ti^{*};l;\phi$ by \refrule{Code}.

        \item Case: $S;(ti^{*};l;\phi)^{?}
        \begin{stackTL}
            \vdash_i v_1^j \; (t.\<const> c) \; v_2^k; (t.\<const> c') \; (\<setlocal> j)
            \\ : ti^{*};l;\phi
        \end{stackTL}$
        \\ $\land$ $v_1^j \; (t.\<const> c) \; v_2^k; (t.\<const> c') \; \<setlocal> j \hookrightarrow v_1^j \; (t.\<const> c') \; v_2^k;\epsilon$

            We want to show that $$S;(ti^{*};l;\phi)^{?} \vdash_i v_1^j \; (t.\<const> c') \; v_2^k; (t.\<const> c') \; (\<setlocal> j) : ti^{*};l;\phi$$

            We know $\vdash (t.\<const> c) : \ti{t}{a};(\circ,\ti{t}{a},(= a\;\ti{t}{c}))$,
            $S;S_\text{inst}(i) \vdash (t.\<const> c') \; (\<setlocal> j) : \epsilon:l_1;\phi_1^j,(\circ,\ti{t}{a},(= a\;\ti{t}{c})),\phi_2^k \rightarrow ti^{*};l;\phi$,
            and $l_1(j) = \ti{t}{a}$, and $C_\text{local}(j) = t$ because they are premises of \refrule{Code} that we have assumed to hold.

            By \reflemma{Inversion} on \refrule{Composition},
            $S;S_\text{inst}(i) \vdash (t.\<const> c') : \epsilon;l_1;\phi_1^j,(\circ,\ti{t}{a},(= a\;\ti{t}{c})),\phi_2^k \rightarrow ti_3^{*};l_3;\phi_3$,
            $S;S_\text{inst}(i) \vdash \<setlocal> j : ti_3^{*};l_3;\phi_3 \rightarrow ti^{*};l;\phi$.

            Recall that $t = C_\text{local}(j)$, then by \reflemma{Inversion} on \refrule{Set-Local} we have
            $ti_3^{*} = ti^{*} \; \ti{t}{a'}$,
            $l = l_3[j := \ti{t}{a'}]$,
            and $\phi_3 \implies \phi$.

            Then, by \reflemma{Inversion} on \refrule{Const},
            $ti^{*} = \epsilon$, $l_1 = l_3$, and\\
            $\phi_1^j,(\circ,\ti{t}{a},(= a\;\ti{t}{c})),\phi_2^k,\ti{t}{a'},(= a'\;\ti{t}{c'}) \implies \phi_3$.

            Now we have all the information we need to derive the same type for $(t.\<const> c')$

            We have $S;S_\text{inst}(i) \vdash \epsilon : \epsilon;l;\phi \rightarrow \epsilon;l;\phi$ by \refrule{Empty}.

            Then, $S;S_\text{inst}(i) \vdash \epsilon : \epsilon;l;\phi_1^j,(\circ,\ti{t}{a},(= a\;\ti{t}{c})),\phi_2^k,\ti{t}{a'},(= a'\;\ti{t}{c'}) \rightarrow \epsilon;l;\phi$ by \refrule{Subtyping}.

            % Since $a$ is fresh in the typing derivation, $C \vdash \epsilon : \epsilon;l;\phi_1^j,\phi_2^k,\ti{t}{a'},(= a'\;\ti{t}{c'}) \rightarrow \epsilon;l;\phi$.

            Since $a$ is fresh, $\phi_1^j,\phi_2^k,\ti{t}{a'},(= a'\;\ti{t}{c'}) \implies \phi_1^j,(\circ,\ti{t}{a},(= a\;\ti{t}{c})),\phi_2^k,\ti{t}{a'},(= a'\;\ti{t}{c'})$.

            Then, $S;S_\text{inst}(i) \vdash \epsilon : \epsilon;l;\phi_1^j,\phi_2^k,\ti{t}{a'},(= a'\;\ti{t}{c'}) \rightarrow \epsilon;l;\phi$ by \refrule{Subtyping}.

            Further, $\vdash (t.\<const> c') : \ti{t}{a'};\circ,\ti{t}{a'},(= a'\;\ti{t}{c'})$ by \refrule{Admin-Const}.

            Therefore, $S;(ti^{*};l;\phi)^{?} \vdash_i v_1^j\;(t.\<const> c')\;v_2^k;\epsilon : ti^{*};l;\phi$ by \refrule{Code}.

            \thought{I set out to write a very verbose proof case, but I didn't expect it to be this verbose.}

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};\<getglobal> j : ti^{*};l;\phi$
        \\ $\land$ $s;\<getglobal> j \hookrightarrow_i s_\text{glob}(i,j)$

            We want to show that $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};s_\text{glob}(i,j) : ti^{*};l;\phi$

            We have $\vdash v: ti_v;\phi_v)^{*}$ and $S;S_\text{inst}(i) \vdash \<getglobal> j : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow ti^{*};l;\phi$ because they are premises of \refrule{Code} that we have assumed to hold.

            Then, by \reflemma{Inversion} on \refrule{Get-Global}, $ti^{*} = \ti{t}{a}$, $l = l_1$, $C_\text{global}(j) = \text{mut}^{?} t$,
            and $\phi_v^{*},\ti{t}{a} \implies \phi$.

            Recall that we assume $\vdash s : S$, then we know
            $S \vdash s_\text{inst}(i) : C$ because it is a premise of \refrule{Store}.

            Recall that $S_\text{global}(i,j) = \text{mut}^{?} t$, then
            $\vdash s_\text{glob}(i,j) : \ti{t}{a_1};\phi_1$ because it is a premise of \refrule{Instance} that we have assumed to hold.

            Now, we can show that $s_\text{glob}(i,j)$ has the appropriate type.

            We have $S;S_\text{inst}(i) \vdash t.\<const> c : \epsilon;l;\phi_v^{*} \rightarrow \ti{t}{a};l;\phi_v^{*},\ti{t}{a},(= a \; \ti{t}{c})$, where $t.\<const> c = s_\text{glob}(i,j)$, by \refrule{Const}.

            We also know $\ti{t}{a},(= a\;\ti{t}{c}) \implies \ti{t}{a}$.

            Thus, $S;S_\text{inst}(i) \vdash s_\text{glob}(i,j) : \epsilon;l;\phi_v^{*} \rightarrow \ti{t}{a};l;\phi$ by \refrule{Subtyping}.

            Recall $\vdash v: ti_v;\phi_v)^{*}$,
            then $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};s_\text{glob}(i,j) : \ti{t}{a};l;\phi$ by \refrule{Code}, having assumed that the other premises hold.

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash v_l^{*};(t.\<const> c) \; (\<setglobal> j) : ti^{*};l;\phi$
        \\ $\land$ $s;(t.\<const> c) \; (\<setglobal> j) \hookrightarrow_i s';\epsilon$, where $s' = s$ with $\text{glob}(i,j) = (t.\<const> c)$

            We want to show that $S;(ti^{*};l;\phi)^{?} \vdash v_l^{*}; \epsilon : ti^{*};l;\phi$.

            We have $\vdash (v_l^{*}:ti_v;\phi_v)^{*}$ and $S;S_\text{inst}(i) \vdash v \; (\<setglobal> j) : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow ti^{*};l;\phi$ because they are premises of \refrule{Code} that we have assumed to hold.

            Further, by \reflemma{Inversion} on \refrule{Composition}, \refrule{Set-Global}, and \refrule{Const}, $ti^{*} = \epsilon$, $l_1 = l$, $C_\text{global}(j) = \text{mut}\;t$,
            and $\phi_v^{*},\ti{t}{a},(= a\;\ti{t}{c}) \implies \phi$.

            % By \reflemma{Inversion} on \refrule{Composition},
            % $C \vdash v : \epsilon;l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
            % and $C \vdash \<setglobal> j : ti_2^{*};l_2;\phi_2 \rightarrow ti^{*};l;\phi$.

            % By \reflemma{Inversion} on \refrule{Set-Global},
            % $ti_2^{*} = ti^{*} \; \ti{t}{a}$, $l_2 = l$, $C_\text{global}(j) = \text{mut}\;t$,
            % and $\phi_2, \implies \phi$.

            % By \reflemma{Inversion} on \refrule{Const},
            % $t.\<const> c = v$, $ti_2^{*} = \ti{t}{a}$, $l_1 = l_2$,
            % and $\phi_1,\ti{t}{a},(= a\;\ti{t}{c}) \implies \phi_2$.

            We have $S;S_\text{inst}(i) \vdash \epsilon : \epsilon;l;\phi \rightarrow \epsilon;l;\phi$ by \refrule{Empty}.

            Since $a$ is fresh, $\phi_v^{*} \implies \phi_v^{*},\ti{t}{a},(= a\;\ti{t}{c})$.

            Thus $S;S_\text{inst}(i) \vdash \epsilon : \epsilon;l;\phi_v^{*} \rightarrow \epsilon;l;\phi$ by \refrule{Subtyping}.

            Recall that $\vdash (v_l^{*}:ti_v;\phi_v)^{*}$,
            then $S;(ti^{*};l;\phi)^{?} \vdash_i v_l^{*};\epsilon : ti^{*};l;\phi$ by \refrule{Code}.

            Now we must ensure that the new store $s'$ is well typed: $\vdash s' : S$.

            Recall $\vdash s : S$, then $S_\text{glob}(i,j)=\text{mut}^{?}\;t$ and $s_\text{glob}(i,j)=(t.\<const> c')$ where $\vdash (t.\<const> c') : \ti{t}{a_g};\circ,\ti{t}{a_g},(= a_g\; \ti{t}{c'})$ because it is a premise of $\vdash s : S$.

            We know $\vdash (t.\<const> c) : (t.\<const> c) : \ti{t}{a_{g2}};\circ,\ti{t}{a_{g2}},(= a_{g2}\; \ti{t}{c})$, and therefore $\vdash s' : S$ by \refrule{Store}.

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};(\<ithreetwo>.\<const> k)\;(t.\<load> align\;o) : ti^{*};l;\phi$
        \\ $\land$ $s;(\<ithreetwo>.\<const> k)\;(t.\<load> align\;o) \hookrightarrow_i
        {\begin{stackTL}
            t.\<const> \text{const}_t(b^{*}),
            \\ \text{where }s_\text{mem}(i,k+o,|t|) = b^{*}
        \end{stackTL}}$

            We want to show that $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*}; (t.\<const> \text{const}_t(b^{*})) : ti^{*};l;\phi$

            We know $(\vdash v : ti_v;\phi_v)^{*}$ and $S;C \vdash (\<ithreetwo>.\<const> k)\;(t.\<load> align\;o) : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow ti^{*};l;\phi$ because they are premises of \refrule{Code} which we have assumed to hold.

            Then, by \reflemma{Inversion} on \refrule{Composition}, \refrule{Const}, \refrule{Mem-Load}, we know
            $ti^{*} = \ti{t}{a}$, $ti_v^{*} = l$, and $\phi_v^{*},\ti{t}{a} \implies \phi$.

            We have $$S;S_\text{inst}(i)
            \begin{stackTL}
                \vdash t.\<const> \text{const}_t(b^{*})
                \\ : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow \ti{t}{a};l;\phi_v^{*},\ti{t}{a},(= a\;\ti{t}{c})
            \end{stackTL}$$ by \refrule{Const}.

            Then, $S;S_\text{inst}(i) \vdash (t.\<const> \text{const}_t(b^{*})) : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow \ti{t}{a};l;\phi$ by \refrule{Subtyping}.

            Recall $(\vdash v : ti_v;\phi_v)^{*}$, then
            $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};t.\<const> \text{const}_t(b^{*}) : ti^{*};l;\phi$ by \refrule{Code}.

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};(\<ithreetwo>.\<const> k)\;(t.\<load> tp_sx\;align\;o) : ti^{*};l;\phi$
        \\ $\land$ $s;(\<ithreetwo>.\<const> k)\;(t.\<load> tp_sx\;align\;o) \hookrightarrow_i s;t.\<const> \text{const}_t^{sx}(b^{*})$, where $s_\text{mem}(i,k+o,|tp|) = b^{*}$

            Similar to above case, except with $|tp|$ replacing $|t|$ and $\text{const}^{sx}_t(b^{*})$ instead of $\text{const}_t(b^{*})$.

        \item Case: $S;(ti^{*};l;\phi)^{?}
        {\begin{stackTL}
            \vdash_i v^{*};(\<ithreetwo>.\<const> k)\;(t.\<load> tp\_sx^{?}\;align\;o)
            \\ : ti^{*};l;\phi
        \end{stackTL}}$
        \\ $\land$ $s;(\<ithreetwo>.\<const> k)\;(t.\<load> tp\_sx^{?}\;align\;o) \hookrightarrow_i \<trap>$

            We know $(\vdash v : ti_v;\phi_v)^{*}$ because it is a premise of \refrule{Code} which we have assumed to hold.

            We have $S;S_\text{inst}(i) \vdash \<trap> : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow ti^{*};l;\phi$ by \refrule{Trap}.

            Then, $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};\<trap>$ by \refrule{Code}.

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};(\<ithreetwo>.\<const> k)\;(t.\<const> c)\;(t.\<store> align\;o) : ti^{*};l;\phi$
        \\ $\land$ $s;(\<ithreetwo>.\<const> k)\;(t.\<const> c)\;(t.\<store> align\;o) \hookrightarrow_i s';\epsilon$, where $s' = s \text{ with } \text{mem}(i,k+o,|t|) = \text{bits}_t^{|t|}(c)$

            We know $(\vdash v : ti_v;\phi_v)^{*}$ and
            $$S;S_\text{inst}(i)
            {\begin{stackTL}
                \vdash (\<ithreetwo>.\<const> k)\;(t.\<const> c)\;(t.\<store> align\;o)
                \\: \epsilon;ti_v^{*};\phi_v^{*} \rightarrow ti^{*};l;\phi
            \end{stackTL}}$$
            because they are premises of \refrule{Code} which we have assumed to hold.

            Then, by \reflemma{Inversion} on \refrule{Composition}, \refrule{Const}, and \refrule{Mem-Store}, we have
            $ti^{*} = \epsilon$, $ti_v = l$, and $\phi_v^{*},\ti{\<ithreetwo>}{a_1},(= a_1\;\ti{\<ithreetwo>}{k}),\ti{t}{a_2},(= a_2\;\ti{t}{c}) \implies \phi$.

            Since $a_1$ and $a_2$ are fresh, $\phi_v^{*} \implies \phi$.

            We have $S;S_\text{inst}(i) \vdash \epsilon : \epsilon;l;\phi_v^{*} \rightarrow \epsilon;l;\phi_v^{*}$ by \refrule{Empty}.

            Then, $S;S_\text{inst}(i) \vdash \epsilon : \epsilon;ti_v;\phi_v^{*} \rightarrow \epsilon;l;\phi$ by \refrule{Subtyping}.

            Recall that $(\vdash v : ti_v;\phi_v)^{*}$.
            Therefore, $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};\epsilon : ti^{*};l;\phi$ by \refrule{Code}.

            Now we must ensure that the new store $s'$ is well typed: $\vdash s' : S$.

            Recall $\vdash s : S$, then $S_\text{mem}(i)=n$ and $s_\text{mem}(i)=b^{*}$ where $n \leq |b^{*}|$ because it's a premise of \refrule{Store}.

            Since $s' = s \text{ with } \text{mem}(i,k+o,|t|) = \text{bits}_t^{|t|}(c)$, then $|s'_text{mem}(i)|=|s_text{mem}(i)|$, and therefore $n \leq |s'_text{mem}(i)|$, so $s' : S$ by \refrule{Store}.

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};(\<ithreetwo>.\<const> k)\;(t.\<const> c)\;(t.\<store> tp\;align\;o) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        $\land$ $\vdash s : S$
        \\ $\land$ $s;(\<ithreetwo>.\<const> k)\;(t.\<const> c)\;(t.\<store> tp\;align\;o) \hookrightarrow_i s';\epsilon$, where $s' = s \text{ with } \text{mem}(i,k+o,|tp|)=\text{bits}_t^{|tp|}(c)$

            Similar to above case, except with $|tp|$ replacing $|t|$ and $\text{const}^{sx}_t(b^{*})$ instead of $\text{const}_t(b^{*})$.

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};(\<ithreetwo>.\<const> k)\;(t.\<const> c)\;(t.\<store> tp^{?}\;align\;o) : ti^{*};l;\phi$
        \\ $\land$ $s;(\<ithreetwo>.\<const> k)\;(t.\<const> c)\;(t.\<store> tp^{?}\;align\;o) \hookrightarrow_i \<trap>$

            We know $(\vdash v : ti_v;\phi_v)^{*}$ because it is a premise of \refrule{Code} which we have assumed to hold.

            We have $S;S_\text{inst}(i) \vdash \<trap> : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow ti^{*};l;\phi$ by \refrule{Trap}.

            Then, $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};\<trap>$ by \refrule{Code}.

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};\<currentmemory> : ti^{*};l;\phi$
        \\ $\land$ $s;\<currentmemory> \hookrightarrow_i \<ithreetwo>.\<const> |s_\text{mem}(i,*)|/64\text{Ki}$

            We know $(\vdash v : ti_v;\phi_v)^{*}$ and $S;S_\text{inst}(i) \vdash \<currentmemory> : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow ti^{*};l;\phi$ because they are premises of \refrule{Code} which we have assumed to hold.

            Then, by \reflemma{Inversion} on \refrule{Current-Memory}, $ti^{*} = \ti{\<ithreetwo>}{a}$, $ti_v^{*} = l$, and $\phi_v^{*},\ti{\<ithreetwo>}{a} \implies \phi$.

            Let $c = |s_\text{mem}(i,*)|/64\text{Ki}$.
            Although note that the actual value of $c$ is irrelevant to the rest of the proof case.

            $S;S_\text{inst}(i) \vdash \<ithreetwo>.\<const> c : \epsilon;l;\phi_v^{*} \rightarrow \ti{\<ithreetwo>}{a};l;\phi_v^{*},\ti{\<ithreetwo>}{a},(= a\;\ti{\<ithreetwo>}{c})$ by \refrule{Const}.

            $S;S_\text{inst}(i) \vdash \<ithreetwo>.\<const> c : \epsilon;ti^{*};\phi_v^{*} \rightarrow \ti{\<ithreetwo>}{a};l;\phi$ by \refrule{Subtyping}.

            Recall that $(\vdash v : ti_v;\phi_v)^{*}$.
            Thus, $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};\<ithreetwo>.\<const> c : ti^{*};l;\phi$ by \refrule{Code}.

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};(\<ithreetwo>.\<const> k) \; \<growmemory> : ti^{*};l;\phi$
        \\ $\land$ $s;(\<ithreetwo>.\<const> k) \; \<growmemory> \hookrightarrow_i s';\<ithreetwo>.\<const> |s_\text{mem}(i,*)|/64\text{Ki}$,
        \\ where $s' = s \text{ with } \text{mem}(i,*) = s_\text{mem}(i,*)(0)^{k \cdot 64\text{Ki}}$

            We have $(\vdash v : ti_v;\phi_v)^{*}$ and $S;S_\text{inst}(i) \vdash (\<ithreetwo>.\<const> k) \; \<growmemory>  : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow ti^{*};l;\phi$ because they are premises of \refrule{Code} which we have assumed to hold.

            By \reflemma{Inversion} on \refrule{Composition}, \refrule{Const}, and \refrule{Grow-Memory}, we also have
            $ti^{*} = \ti{\<ithreetwo>}{a_1}$, $ti_v^{*} = l$, and $\phi_v^{\phi_v},\ti{\<ithreetwo>}{a_2},(= a_2\;\ti{\<ithreetwo>}{k}),\ti{\<ithreetwo>}{a_1} \implies \phi$.

            Further, $S_\text{mem}(i) \leq |s_\text{mem}(i,*)|$ because it is a premise of \refrule{Store} on $\vdash s : S$, which we have assumed to hold.

            Let $c = \<ithreetwo>.\<const> |s_\text{mem}(i,*)|/64\text{Ki}$.
            Although note that the actual value of $c$ is irrelevant to the rest of the proof case.

            $$S;S_\text{inst}(i) \vdash \<ithreetwo>.\<const> c :
            {\begin{stackTL}
                \epsilon;l;\phi_v^{*}
                \\ \rightarrow \ti{\<ithreetwo>}{a_1};l;\phi_v^{*},\ti{\<ithreetwo>}{a_1},(= a_1\;\ti{\<ithreetwo>}{c})
            \end{stackTL}}$$ by \refrule{Const}.

            Since $a_2$ is fresh, $\phi_v^{*},\ti{\<ithreetwo>}{a_1} \implies \phi$.

            $S;S_\text{inst}(i) \vdash \<ithreetwo>.\<const> c : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow \ti{\<ithreetwo>}{a_1};l;\phi$ by \refrule{Subtyping}.

            $S;(ti^{*};l;\phi)^{?} \vdash_i \<ithreetwo>.\<const> c : ti^{*};l;\phi$ by \refrule{Code}.

            Now we must ensure that the new store $s'$ is well typed: $\vdash s' : S$.

            Recall $\vdash s : S$, then $S_\text{mem}(i)=n$ and $s_\text{mem}(i)=b^{*}$ where $n \leq |b^{*}|$ because it's a premise of \refrule{Store}.

            Since $s' = s \text{ with } \text{mem}(i,*) = s_\text{mem}(i,*)(0)^{k \cdot 64\text{Ki}}$, then $|s'_\text{mem}(i)|>|s_\text{mem}(i)|$, and therefore $n \leq |s'_\text{mem}(i)|$, so $s' : S$ by \refrule{Store}.

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};(\<ithreetwo>.\<const> k) \; \<growmemory> : ti^{*};l;\phi$
        \\ $\land$ $s;(\<ithreetwo>.\<const> k) \; \<growmemory> \hookrightarrow_i \<ithreetwo>.\<const> (-1)$

            Same as above case since the value of $c$ is irrelevant (and can therefore be -1).

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_j v_0^{*};\<local>\{i;v^{*}\}\; e^{*} : ti^{*};l;\phi$
        \\ $\land$ $s;v_0^{*};\<local>\{i;v^{*}\}\; e^{*} \hookrightarrow_j s';v_0^{*};\<local>\{i;v'^{*}\}\; e'^{*}$
        \\ where $s;v^{*};e^{*} \hookrightarrow_i s';v'^{*};e'^{*}$

            We want to show that $\vdash_j s';v_0^{*};\<local>\{i;v'^{*}\}\; e'^{*} : ti^{*};l;\phi$.

            First, we will derive the type of the body of the local block.

            We have $S;S_\text{inst}(j) \vdash \<local>\{i;v^{*}\}\; e^{*} : \epsilon;ti_v^{*};\phi_{v0}^{*} \rightarrow ti^{*};l;\phi$ where $(\vdash v_0 : ti_v;\phi_{v0})^{*}$ because they are premises of \refrule{Code}.

            Then, $S;(ti^{*};l;\phi) \vdash_i v^{*};e^{*} : ti^{*};l;\phi_0$, where $\phi_0 \implies \phi$ by \reflemma{Inversion} on \refrule{Local}.

            Now, we invoke the inductive hypothesis and use it to rebuild the original type.

            Since $S;(ti^{*};l;\phi) \vdash_i v^{*};e^{*} : ti^{*};l;\phi_0$, $s \vdash S$ and $s;v^{*};e^{*} \hookrightarrow_i s';v'^{*};e'^{*}$, then by the inductive hypothesis we know that $\vdash s' : S$ and $$S;(ti^{*};l;\phi) \vdash_i v'^{*};e'^{*} : ti^{*};l;\phi_0$$

            Thus, $S;S_\text{inst}(j) \vdash \<local>\{i;v'^{*}\}\; e'^{*} : \epsilon;ti_v^{*};\phi_{v0}^{*} \rightarrow ti^{*};l;\phi$ by \refrule{Local}.

            Finally, $S;(ti^{*};l;\phi)^{?} \vdash_i v_0^{*};\<local>\{i;v'^{*}\}\; e'^{*} : ti^{*};l;\phi$ and $\vdash s' : S$.

        \item Case: $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};L^{k}[e^{*}] : ti^{*};l;\phi$
        \\ $\land$ $s;v^{*};L^{k}[e^{*}] \hookrightarrow_i s';v'^{*};L^{k}[e'^{*}]$
        \\ where $s;v^{*};e^{*} \hookrightarrow_i s';v'^{*};e'^{*}$

            We want to show that $S;(ti^{*};l;\phi)^{*} \vdash_i L^k[e'^{*}] : ti^{*};l;\phi$.

            First, we will derive the type of the body of the local context.

            We have $S;C \vdash L^k[e^{*}] : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow ti^{*};l;\phi$, \\
            where $C = S_\text{inst}(i),\text{local } t_v^{*},\text{return } (ti^{*};l;\phi)^{?}$ because it is a premise of \refrule{Code}.

            The intuition for the proof is that there is no requirement on what the label stack is of the module type context $C$ under which $L^k[e^{*}]$ is typed.
            Thus, we can reduce $e^{*}$ outside of $L^k$, but with the module type context $C$ as if it were inside of $L^k$.

            The proof continues via induction on $k$.
            \begin{itemize}
                \item Case: $k = 0$

                    $L^k[e^{*}] = v_0^{*}\; e^{*}\; e_0^{*}$.

                    By \reflemma{Inversion} on \refrule{Composition} and \refrule{Const}
                    $S;C \vdash e^{*} : ti_1^{*};ti_v^{*};\phi_v^{*},\phi_{v0}^{*} \rightarrow ti_2^{*};l_2;\phi_2$ and
                    \\$S;C \vdash e_0^{*} : ti_2^{*};l_2;\phi_2 \rightarrow ti^{*};l;\phi$.

                    Since $s;v^{*};e^{*}$ reduces, $e^{*}$ can be typed with an empty stack precondition.
                    Therefore $ti_2^{*} = ti_1^{*}\;ti_3^{*}$ and $S;C \vdash e^{*} : \epsilon;ti_v^{*};\phi_v^{*},\phi_{v0}^{*} \rightarrow ti_3^{*};l_2;\phi_2$.

                    Since $\phi_{v0}^{*}$ only contains fresh index variables, $\phi_v^{*} \implies \phi_v^{*},\phi_{v0}^{*}$.

                    $S;C \vdash e^{*} : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow ti_3^{*};l_2;\phi_2$ by \refrule{Implies}.

                    Then, $S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};e^{*} : ti_3^{*};l_2;\phi_2$ by \refrule{Code}.

                    Now, we invoke the \reflemma{Subject Reduction for Code} inductive hypothesis and rebuild the type using the reduced expression.

                    Since $S;(ti^{*};l;\phi)^{*} \vdash_i v^{*};e^{*} : ti_3^{*};l_2;\phi_2$, $s \vdash S$, and $s;v^{*};e^{*} \hookrightarrow_i s';v';e'^{*}$, then by the inductive hypothesis we know that $\vdash s' : S$ and $S;(ti^{*};l;\phi) \vdash_i v'^{*};e'^{*} : ti_3^{*};l_2;\phi_2$.

                    $S;C \vdash e'^{*} : \epsilon;ti_{v'}^{*};\phi_{v'}^{*} \rightarrow ti_3^{*};l_2;\phi_2$ because it is a premise of \refrule{Code}.

                    % $S;C \vdash v_0^{*}\; e'^{*}\; e_0^{*} : \epsilon;ti_{v'}^{*};\phi_{v'}^{*},\phi_{v0}^{*} \rightarrow ti^{*};l;\phi$ by \refrule{Const}, \refrule{Implies}, and \refrule{Composition}.

                    $S;C \vdash v_0^{*} : \epsilon;ti_{v'}^{*};\phi_{v'}^{*} \rightarrow ti_1^{*};ti_{v'}^{*};\phi_{v'}^{*},\phi_{v0}^{*}$ by \refrule{Const}.

                    $S;C \vdash e'^{*} : ti_1^{*};ti_{v'}^{*};\phi_{v'}^{*},\phi_{v0}^{*} \rightarrow ti_2^{*};l_2;\phi_2$ by \refrule{Implies} and \refrule{Stack-Poly}.

                    $S;C \vdash v_0^{*}\; e'^{*}\; e_0^{*} : \epsilon;ti_{v'}^{*};\phi_{v'}^{*},\phi_{v0}^{*} \rightarrow ti^{*};l;\phi$ by \refrule{Composition}.

                    Therefore, $S;(ti^{*};l;\phi)^{*} \vdash_i L^k[e'^{*}] : ti^{*};l;\phi$ and $\vdash s' : S$.

                \item Case: $k > 0$

                    $L^k[e^{*}] = v_k^{*}\; \<label>_n \{ e_0^{*} \}\; L^{k-1}[e^{*}] \<end>\; e_k^{*}$.

                    By \reflemma{Inversion} on \refrule{Const} and \refrule{Composition},
                    $S;C \vdash \<label>_n \{ e_0^{*} \}\; L^{k-1}[e^{*}] \<end> : ti_1^{*};ti_v^{*};\phi_v^{*},\phi_{vk}^{*} \rightarrow ti_2^{*};l_2;\phi_2$ and
                    $S;C \vdash e_k^{*} : ti_2^{*};l_2;\phi_2 \rightarrow ti^{*};l;\phi$.

                    By \reflemma{Inversion} on \refrule{Label},
                    $ti_2^{*} = ti_1^{*} \; ti_3^{*}$,
                    $S;C \vdash e_0^{*} : ti_4^{*};l_4;\phi_4 \rightarrow ti_3^{*};l_2;\phi_2$, and
                    $S;C,\text{label } (ti_4^{*};l_4;\phi_4) \vdash L^{k-1}[e^{*}] : \epsilon;ti_v^{*};\phi_v^{*},\phi_{vk}^{*} \rightarrow ti_3^{*};l_2;\phi_2$.

                    Since $\phi_{vk}^{*}$ only contains fresh index variables, $\phi_v^{*} \implies \phi_v^{*},\phi_{vk}^{*}$.

                    $S;C,\text{label } (ti_4^{*};l_4;\phi_4) \vdash L^{k-1}[e^{*}] : \epsilon;ti_v^{*};\phi_v^{*} \rightarrow ti_3^{*};l_2;\phi_2$ by \refrule{Implies}.

                    $S;(ti^{*};l;\phi)^{?} \vdash v^{*};L^{k-1}[e^{*}] : ti_3^{*};l_2;\phi_2$ by \refrule{Code}.

                    \thought{It might seem like we can't do this, but the store typing never specifies what the labels of it's contexts are, so we can just do whatever?}

                    Now, we invoke the inductive hypothesis on $L^{k-1}[e^{*}]$ and rebuild the type using the reduced expression.

                    Since $S;(ti^{*};l;\phi)^{*} \vdash_i v^{*};L^{k-1}[e^{*}] : ti_3^{*};l_2;\phi_2$, $s \vdash S$, and
                    \\ $s;v^{*};e^{*} \hookrightarrow_i s';v';e'^{*}$, then by the inductive hypothesis on
                    \\ $L^{k-1}[e^{*}]$ we know that $\vdash s' : S$ and
                    \\ $S;(ti^{*};l;\phi) \vdash_i v'^{*};L^{k-1}[e'^{*}] : ti_3^{*};l_2;\phi_2$

                    $S;C,\text{label } \vdash L^{k-1}[e'^{*}] : \epsilon;ti_{v'}^{*};\phi_{v'}^{*} \rightarrow ti_3^{*};l_2;\phi_2$ because it is a premise of \refrule{Code}.

                    $S;C \vdash v_k^{*} : \epsilon;ti_{v'}^{*};\phi_{v'}^{*} \rightarrow ti_1^{*};ti_{v'}^{*};\phi_{v'}^{*},\phi_{vk}^{*}$ by \refrule{Const}.

                    $S;C \vdash \<label>_n \{ e_0^{*} \}\; L^{k-1}[e'^{*}] \<end> : \epsilon;ti_{v'}^{*};\phi_{v'}^{*} \rightarrow ti_3^{*};l_2;\phi_2$ by \refrule{Label}.

                    $S;C \vdash \<label>_n \{ e_0^{*} \}\; L^{k-1}[e'^{*}] \<end> : ti_1^{*};ti_{v'}^{*};\phi_{v'}^{*},\phi_{vk}^{*} \rightarrow ti_2^{*};l_2;\phi_2$ by \refrule{Implies} and \refrule{Stack-Poly}.

                    $S;C \vdash v_k^{*}\; \<label>_n \{ e_0^{*} \}\; L^{k-1}[e^{*}] \<end>\; e_k^{*} : \epsilon;ti_{v'}^{*};\phi_{v'}^{*} \rightarrow ti^{*};l;\phi$ by \refrule{Composition}.

                    Therefore, $S;(ti^{*};l;\phi)^{*} \vdash_i L^k[e'^{*}] : ti^{*};l;\phi$ and $\vdash s' : S$.

            \end{itemize}

        \item Otherwise: we have $(\vdash (t.\<const> c) : \ti{t}{a};(\circ,\ti{t}{a},(= a\; \ti{t}{c})))^{*}$, and $S,S_\text{inst}(i) \vdash e^{*} : \epsilon;\ti{t}{a}^{*};(\circ,\ti{t}{a},(= a\; \ti{t}{c}))^{*} \rightarrow ti;l;\phi$

            By \reflemma{Subject Reduction Without Effects}, we have
            \\$S,S_\text{inst}(i) \vdash e'^{*} : \epsilon;\ti{t}{a}^{*};(\circ,\ti{t}{a},(= a\; \ti{t}{c}))^{*} \rightarrow ti;l;\phi$.

            Then, $S;(ti^{*};l;\phi)^{?} \vdash v^{*};e'^{*} : ti;l;\phi$
    \end{itemize}
\end{proof}

\begin{lemma}{\scshape{Subject Reduction Without Effects}}

    If $S;C \vdash e^{*} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,
    \\ $\vdash s : S$ (note: we omit this for cases which do not use s),
    \\ and $s;v^{*};e^{*} \hookrightarrow s;v^{*};e'^{*}$,
    \\then $S;C \vdash e'^{*} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
\end{lemma}
\begin{proof}
    \label{proof:subreduxnoeffects}

    By case analysis on the reduction rules.

    \begin{itemize}
        \item $S;C \vdash L^0[\<trap>] : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $L^0[\<trap>] \hookrightarrow \<trap>$

            This case is trivial since $\<trap>$ accepts any precondition and postcondition.
            Thus, $S;C\vdash \<trap> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ by \refrule{Trap}.

        %% Binop -> const
        \item $S;C \vdash (t.\<const> c_1)\; (t.\<const> c_2)\; t.binop : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $(t.\<const> c_1)\; (t.\<const> c_2)\; t.binop \hookrightarrow t.\<const> c$ where $c=binop(c_1,c_2)$

            We want to show that $S;C \vdash t.\<const> c : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            We begin by reasoning about the type of the original instructions $(t.\<const> c_1)\; (t.\<const> c_2)\; t.binop$

            By \reflemma{Inversion} on \refrule{Composition}, \refrule{Const}, and \refrule{Binop}, we know that $ti_2^{*} = ti_1^{*} \ti{t}{a_3}$, $l_2=l_1$, and that
            $$
                \phi_1,
                {\begin{stackTL}
                    \ti{t}{a_1}, (= a_1\; \ti{t}{c_1}), \\
                    \ti{t}{a_2}, (= a_2\; \ti{t}{c_2}), \\
                    \ti{t}{a_3}, (= a_3\; (binop\; a_1\; a_2))
                \end{stackTL}}
                \implies \phi_2
            $$

            Now we will show that $t.\<const> c$ has the appropriate type.

            By $const$, $S;C \vdash t.\<const> c :
                \begin{stackTL}
                    \epsilon;l_1;\phi_1 \\
                    \rightarrow \ti{t}{a_3};l_1;\phi_1,\ti{t}{a_3},(= a_3\;\ti{t}{c})
                \end{stackTL}$.

            Because $c=binop_t(c_1,c_2)$, then by $\implies$,
            $$
                \phi_1,\ti{t}{a},(= a\; \ti{t}{c}) \implies \phi_1,
                {\begin{stackTL}
                    \ti{t}{a_1}, (= a_1\; \ti{t}{c_1}), \\
                    \ti{t}{a_2}, (= a_2\; \ti{t}{c_2}), \\
                    \ti{t}{a_3}, (= a_3\; (binop\; a_1 a_2))
                \end{stackTL}}
            $$

            Therefore, $S;C \vdash (t.\<const> c) : ti_1^{*};l_1;\phi_1 \rightarrow ti_1^{*}\; \ti{t}{a_3};l_1;\phi_2$, by \refrule{Stack-Poly} and \refrule{Subtyping}.

        %% Binop -> trap
        \item  $C\vdash (t.\<const> c_1)\; (t.\<const> c_2)\; t.binop : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $(t.\<const> c_1)\; (t.\<const> c_2)\; t.binop \hookrightarrow \<trap>$

            This case is trivial since $\<trap>$ accepts any precondition and postcondition.
            Thus, $S;C\vdash \<trap> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ by \refrule{Trap}.

        %% Testop
        \item $C\vdash (t.\<const> c)\; t.testop : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $(t.\<const> c)\; t.testop \hookrightarrow \<ithreetwo>.\<const> c_2$ where $c_2=testop(c)$

            We want to show that $S;C \vdash \<ithreetwo>.\<const> c_2 : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            First, we use our reasoning principles to get more information about the original type.

            By \reflemma{Inversion} on \refrule{Composition}, \refrule{Const}, and \refrule{Testop}, we know that $ti_2^{*}=ti_1^{*}\; \ti{t}{a_2}$, $l_2=l_1$, and that
            \begin{align*}
                \phi_1&,
                \begin{stackTL}
                    \ti{t}{a_1}, (= a_1\;\ti{t}{c}), \\
                    \ti{\<ithreetwo>}{a_2}, (= a_2\;(testop\;a_1))
                \end{stackTL} \\
                &\implies \phi_2
            \end{align*}

            Now we show that $\<ithreetwo>.\<const> c_2$ has the appropriate type.

            By $const$, $C \vdash \<ithreetwo>.\<const> c_2 :
                \begin{stackTL}
                    \epsilon;l_1;\phi_1 \\
                    \rightarrow \ti{\<ithreetwo>}{a_2};l_1;\phi_1,\ti{\<ithreetwo>}{a_2},(= a_2\;\ti{t}{c_2})
                \end{stackTL}$.

            Because $c_2=testop(c)$, then by $\implies$,
            $$
                \phi_1,\ti{t}{a},(= a\;\ti{t}{c_2}) \implies \phi_1,
                {\begin{stackTL}
                    \ti{t}{a_1}, (= a_1\;\ti{t}{c}), \\
                    \ti{\<ithreetwo>}{a_2}, (= a_2\;(testop\;a_1))
                \end{stackTL}}
            $$

            Therefore, $S;C \vdash t.\<const> c_2 : ti_1^{*};l_1;\phi_1 \rightarrow ti_1^{*}\; \ti{t}{a_2};l_1;\phi_2$, by \refrule{Stack-Poly} and \refrule{Subtyping}

        %% Relop
        \item $S;C \vdash (t.\<const> c_1)\; (t.\<const> c_2)\; t.relop : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $(t.\<const> c_1)\; (t.\<const> c_2)\; t.relop \hookrightarrow t.\<const> c$ where $c=relop(c_1,c_2)$

            This case is identical to the $(t.\<const> c_1)\; (t.\<const> c_2)\; t.binop \hookrightarrow t.\<const> c$ case, except that $binop$ is replaced with $relop$.

        %% Unreachable
        \item $S;C \vdash \<unreachable> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $\<unreachable> \hookrightarrow \<trap>$

            This case is once again trivial since $\<trap>$ accepts any precondition and postcondition.
            Thus, $S;C \vdash \<trap> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ by $trap$.

        %% Nop
        \item $S;C \vdash \<nop> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $\<nop> \hookrightarrow \epsilon$

            We want to show that $S;C \vdash \epsilon : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            This case follows from the fact that the postcondition $ti_2^{*};l_2;\phi_2$ for $\<nop>$ must be immediately reachable from the precondition $ti_1^{*};l_1;\phi_1$.

            By \reflemma{Inversion} on \refrule{Nop}, we know that $ti_2^{*} = ti_1^{*}$, $l_2 = l_1$, and $\phi_1 \implies \phi_2$.

            Then, $S;C\vdash \epsilon : \epsilon;l;g;\phi_1 \rightarrow \epsilon;l;g;\phi_1$ by \refrule{Empty}.

            Thus, $S;C \vdash \epsilon ti_1^{*};l;g;\phi_1 \rightarrow ti_1^{*};l;g;\phi_2$ by \refrule{Stack-Poly} and \refrule{Subtyping}.

        %% Drop
        \item $S;C \vdash (t.\<const> c)\; \<drop> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $(t.\<const> c)\; \<drop> \hookrightarrow \epsilon$

            We want to show that $S;C \vdash \epsilon : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            Like the above case, this follow from the fact that the postcondition $ti_2^{*};l_2;\phi_2$ must be immediately reachable from the precondition $ti_1^{*};l_1;\phi_1$.
            However, there are a few extra steps since we now have to reason about two different instructions (and therefore \refrule{Composition}).

            By \reflemma{Inversion} on \refrule{Composition}, \refrule{Const}, and \refrule{Drop}, we know that $ti_2^{*} = ti_1^{*}$, $l_2 = l_1$, and $\phi_1 \implies \phi_2$.

            By $empty$, $S;C \vdash \epsilon : \epsilon;l_1;\phi_1 \rightarrow \epsilon;l_1;\phi_1$.

            Thus, $S;C \vdash \epsilon ti_1^{*};l;g;\phi_1 \rightarrow ti_1^{*};l;g;\phi_2$ by \refrule{Stack-Poly} and \refrule{Subtyping}.

        %% Select
        \item Case: $S;C\; {\begin{stackTL}
            \vdash (t.\<const> c_1)\;(t.\<const> c_2)\;(\<ithreetwo>.\<const> 0)\;\<select>
            \\ : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2
        \end{stackTL}}$
        \\ $\land$ $(t.\<const> c_1)\;(t.\<const> c_2)\;(\<ithreetwo>.\<const> 0)\;\<select> \hookrightarrow (t.\<const> c_2)$

            We want to show that $S;C\vdash (t.\<const> c_2) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            First, we reason about what the original type must look like.

            By \reflemma{Inversion} on \refrule{Composition}, \refrule{Const}, and \refrule{Select}, we know that $ti_2^{*} = ti_1^{*}\;\ti{a_3}$, $l_2 = l_1$, and
            $$
            {\begin{stackTL}
                \phi_1, {\begin{stackTL}
                    \ti{t}{a_1}, (= a_1\;\ti{t}{c_1}), \\
                    \ti{t}{a_2}, (= a_2\;\ti{t}{c_2}), \\
                    \ti{\<ithreetwo>}{a}, (= a\;\ti{\<ithreetwo>}{0}), \\
                    \ti{t}{a_3},(if\; (= a\; \ti{\<ithreetwo>}{0})\; (= a_3\; a_2)\; (= a_3\; a_1))
                \end{stackTL}} \\
                \implies \phi_2
            \end{stackTL}}
            $$

            Now we show that $(t.\<const> c_2)$ has the appropriate type.

            By \refrule{Const}, \\
            $ C \vdash (t.\<const> c_2) :
                {\begin{stackTL}
                    \epsilon;l_1;\phi_1 \\
                    \rightarrow \ti{t}{a_3};l_1;\phi_1,\ti{t}{a_3},(= a_3\; \ti{t}{c_2}) \\
                \end{stackTL}} $

            Then, $S;C \vdash (t.\<const> c_2) : ti_1^{*};l_1;\phi_1 \rightarrow ti_1^{*}\;\ti{t}{a_3};l_1;\phi_1,\ti{t}{a_3},(= a_3 \; \ti{t}{c_2})$ by \refrule{Stack-Poly}.

            By $\implies$, we have
            $$\phi_1,\ti{t}{a_3},(= a_3\; \ti{t}{c_2}) \implies \phi_1, {\begin{stackTL}
                \ti{t}{a_1}, (= a_1\; \ti{t}{c_1}), \\
                \ti{t}{a_2}, (= a_2\; \ti{t}{c_2}), \\
                \ti{\<ithreetwo>}{a}, (= a\;\ti{\<ithreetwo>}{0}), \\
                \ti{t}{a_3},(\text{if }
                {\begin{stackTL}
                    (= a\; \ti{\<ithreetwo>}{0})
                    \\ (= a_3\; a_2)
                    \\ (= a_3\; a_1))
                \end{stackTL}}
            \end{stackTL}} \\ $$

            Therefore,
            $S;C \vdash (t.\<const> c_2) :
            ti_1^{*};l_1;\phi_1
                \rightarrow ti_2^{*}\;\ti{t}{a_3};l_1;\phi_2$ by $sub-typing$

        %% Block
        \item Case: $S;C \vdash (t.\<const> c)^n \; \<block>\; (ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4) \; e^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ ${\begin{stackTL}
            (t.\<const> c)^n \; \<block>\; (ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4) \; e^{*} \<end>
            \\ \hookrightarrow \<label>_m \{ \epsilon \} \; (t.\<const> c)^n \; e^{*} \<end>
        \end{stackTL}}$

            We want to show that $\<label>_m \{ \epsilon \} \; (t.\<const> c)^n \; e^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            First, we reason about $ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            We know $S;C
            {\begin{stackTL}
                \vdash \<block>\; (ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4) \; e^{*} \<end>
                \\ : ti_1^{*}\; \ti{t}{a}^n;l_1;\phi_1,\ti{t}{a}^n,(= a \; \ti{t}{c})^n \rightarrow ti_2^{*};l_2;\phi_2
            \end{stackTL}}$\\ by \reflemma{Inversion} on \refrule{Composition} and \refrule{Const}.

            By \reflemma{Inversion} on \refrule{Block}, $l_1=l_3$ and $l_2=l_4$.
            We will use $l_1,l_2$ in place of $l_3,l_4$, respectively, for the remainder of the case.

            Then, $S;C,\text{label}(t_4^{m};l_2;\phi_4) \vdash e^{*} : \ti{t}{a}^n;l_1;\phi_3 \rightarrow ti_4^m;l_2;\phi_4$ because it is a premise of \refrule{Block} which we have already assumed to hold.

            Also, $\ti{t}{a}^n=ti_3^n$, $ti_2^{*}=ti_1^{*}\; ti_4^m$, $\phi_1,\ti{t}{a}^n,(= a \; \ti{t}{c})^n \implies \phi_3$, and $\phi_4 \implies \phi_2$ by \reflemma{Inversion} on \refrule{Block}.

            Now we have all the information we need to show that
            \\$\<label>_m \{ \epsilon \} \; (t.\<const> c)^n \; e^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            Remember that \refrule{Label} uses the types of both the body \\$(t.\<const> c)^n \; e^{*}$ and the stored instructions $\epsilon$.

            First, we show the type of the body.

            We have $$S;C,\text{label}(t_4^{m};l_2;\phi_4) \vdash
            {\begin{stackTL}
                (t.\<const> c)^n : \epsilon;l_1;\phi_1
                \\ \rightarrow \ti{t}{a}^n;l_1;\phi_1,\ti{t}{a}^n,(= a \; \ti{t}{c})^n
            \end{stackTL}}$$ by \refrule{Const}.

            Then, since $\phi_1,\ti{t}{a}^n,(= a \; \ti{t}{c})^n \implies \phi_3$, we have $$S;C,\text{label}(t_3^{n};l_1;\phi_3) \vdash (t.\<const> c)^n : \epsilon;l_1;\phi_1 \rightarrow \ti{t}{a}^n;l_1;\phi_3$$ by \refrule{Subtyping}.

            Recall we have $S;C,\text{label}(t_4^{m};l_2;\phi_4) \vdash e^{*} : \ti{t}{a}^n;l_1;\phi_3 \rightarrow ti_4^m;l_2;\phi_4$.

            Then $S;C,\text{label}(t_4^m;l_2;\phi_4) \vdash (t.\<const> c)^n\; e^{*} : \epsilon;l_1;\phi_1 \rightarrow ti_4^m;l_2;\phi_4$ by \refrule{Composition}.

            We have the type we want from the body.
            Now we get the type we want of the stored instructions.
            We already have the postcondition we want, $t_4^{m};l_2;\phi_4$, in the label stack, so we want the stored instruction to just pass the information through.
            Since the stored instructions is $\epsilon$, this is simple to show: we have $S;C \vdash \epsilon : ti_2^m;l_2;\phi_4 \rightarrow ti_2^m;l_2;\phi_4$ by \refrule{Empty} and \refrule{Stack-Poly}.

            Therefore, $C \vdash \<label>_m \{ \epsilon \} \; (t.\<const> c)^n \; e^{*} \<end> : \epsilon;l_1;\phi_1 \rightarrow ti_2^m;l_2;\phi_4$ by $label$.

            Finally, since $\phi_4 \implies \phi_2$, $S;C \vdash \<label>_m \{ \epsilon \} \; (t.\<const> c)^n \; e^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_1^{*}\; ti_4^m;l_2;\phi_2$ by \refrule{Stack-Poly} and \refrule{Subtyping}.

        %% loop
        \item Case: $S;C \vdash (t.\<const> c)^n \; \<loop>\; (ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4) \; e^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ ${\begin{stackTL}(t.\<const> c)^n \; \<loop>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e^{*} \<end>
            \\ \hookrightarrow \<label>_n \{ \<loop>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e^{*} \<end> \} \; (t.\<const> c)^n \; e^{*} \<end> \end{stackTL}}$

            We want to show that $\<label>_n\;
            {\begin{stackTL}
                \{ \<loop>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e^{*} \<end> \}
                \\ (t.\<const> c)^n \; e^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2
            \end{stackTL}}$

            This rule is similar to the above one, except that we must reason a little more about the stored instructions since we are storing the loop.

            We start by figuring out what $ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ looks like.

            We know
            $$S;C\;
            {\begin{stackTL}
                \vdash \<loop>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e^{*} \<end>
                \\ : ti_1^{*}\; \ti{t}{a}^n;l_1;\phi_1,\ti{t}{a}^n,(= a \; \ti{t}{c})^n \rightarrow ti_2^{*};l_2;\phi_2
            \end{stackTL}}$$
            by \reflemma{Inversion} on \refrule{Composition} and \refrule{Const}.

            By \reflemma{Inversion} on \refrule{Loop}, $l_1=l_3$ and $l_2=l_4$.
            We will use $l_1,l_2$ in place of $l_3,l_4$, respectively, for the remainder of the case.

            Then, $S;C,\text{label}(t_4^{m};l_2;\phi_4) \vdash e^{*} : \ti{t}{a}^n;l_1;\phi_3 \rightarrow ti_4^m;l_2;\phi_4$ because it is a premise of \refrule{Loop} which we have already assumed to hold.

            Also, $\ti{t}{a}^n=ti_3^n$, $ti_2^{*}=ti_1^{*}\; ti_4^m$, $\phi_1,\ti{t}{a}^n,(= a \; \ti{t}{c})^n \implies \phi_3$, and $\phi_4 \implies \phi_2$ by \reflemma{Inversion} on \refrule{Loop}.

            Now we have all the information we need to show that
            $$S;C\;
            {\begin{stackTL}
                \vdash \<label>_n \{ \<loop>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e^{*} \<end> \} \; (t.\<const> c)^n \; e^{*} \<end>
                \\ : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2
            \end{stackTL}}$$

            We have $S;C,\text{label}(t_3^{n};l_1;\phi_3) \vdash (t.\<const> c)^n : \epsilon;l_1;\phi_1 \rightarrow \\ \ti{t}{a}^n;l_1;\phi_1,\ti{t}{a}^n,(= a \; \ti{t}{c})^n$ by \refrule{Const}.

            Then, since $\phi_1,\ti{t}{a}^n,(= a \; \ti{t}{c})^n \implies \phi_3$, we have $$S;C,\text{label}(t_3^{n};l_1;\phi_3) \vdash (t.\<const> c)^n : \epsilon;l_1;\phi_1 \rightarrow \ti{t}{a}^n;l_1;\phi_3$$ by \refrule{Subtyping}.

            Recall that $S;C,\text{label}(t_3^{n};l_1;\phi_3) \vdash e^{*} : ti_1^n;l_1;\phi_3 \rightarrow ti_2^m;l_1;\phi_4$.

            Then $S;C,\text{label}(t_3^{n};l_1;\phi_3) \vdash (t.\<const> c)^n\; e^{*} : \epsilon;l_1;\phi_1 \rightarrow \\ ti_4^m;l_2;\phi_4$ by $composition$.

            We have the type we want from the body.
            Now we get the type we want of the stored instructions, which in this case is the loop.
            Since we already have the necessary type information of the body, we then have that $S;C \vdash \<loop>\; tfi \; e^{*} \<end> : \ti{t}{a}^n;l_1;\phi_1,\ti{t}{a}^n,(= a \; \ti{t}{c})^n \rightarrow ti_4^{m};l_2;\phi_4$ by \refrule{Loop}.

            Therefore, $S;C \vdash \<label>_m \{ \<loop>\; tfi \; e^{*} \<end> \} \; v^n \; e^{*} \<end> : \epsilon;l_1;\phi_1 \rightarrow ti_4^m;l_2;\phi_4$ by \refrule{Label}.

            Finally, since $\phi_4 \implies \phi_2$, $S;C \vdash \<label>_m \{ \epsilon \} \; (t.\<const> c)^n \; e^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ by \refrule{Stack-Poly} and \refrule{Subtyping}.

        \item Case: $S;C \vdash (\<ithreetwo>.\<const> 0) \; \<if>\; (ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4) \; e_1^{*} \<else> e_2^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ ${\begin{stackTL}
            (\<ithreetwo>.\<const> 0) \; \<if>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e_1^{*} \<else> e_2^{*} \<end>
            \\ \hookrightarrow \<block>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e_2^{*} \<end>
        \end{stackTL}}$

            We want to show that $$\<block>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e_1^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$$

            First, we reason about $ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            We know $$S;C
            {\begin{stackTL}
                \vdash \<if>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e_1^{*} \<else> e_2^{*} \<end>
                \\ : ti_1^{*}\; \ti{t}{a};l_1;\phi_1,\ti{t}{a}^n,(= a \; \ti{t}{0})^n \rightarrow ti_2^{*};l_2;\phi_2
            \end{stackTL}}$$ by \reflemma{Inversion} on \refrule{Composition} and \refrule{Const}.

            Then, we have $S;C,\text{label}(ti_4^m;l_4;\phi_4) \vdash e_2^{*} : ti_3^n;l_3;\phi_3,(= a\; \ti{\<ithreetwo>}{0}) \rightarrow ti_4^m;l_4;\phi_4$ because it is a premise of \refrule{If} which we have assumed to hold.

            By \reflemma{Inversion} on \refrule{If}, $ti_1^{*}=ti_0^{*}\; ti_3^{n}$ and $ti_2^{*}=ti_0^{*} \; ti_4^{m}$ for some $ti_0^{*}$, $l_1=l_3$, $l_2=l_4$, $\phi_1,\ti{\<ithreetwo>}{a},(= a\; \ti{\<ithreetwo>}{0}) \implies \phi_3$, and $\phi_4 \implies \phi_2$.

            Now, we show that $\<block>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e_1^{*} \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$

            $S;C \vdash \<block>\; ti_3^n;l_3;\phi_3,(= a\; \ti{\<ithreetwo>}{0}) \rightarrow ti_4^m;l_4;\phi_4 \; e_2^{*} \<end>$ by \refrule{Block}.

            Since $a$ is fresh after reduction, $\phi_1 \implies \phi_1,\ti{\<ithreetwo>}{a},(= a\; \ti{\<ithreetwo>}{0})$ by $\implies$.

            Therefore, $S;C \vdash \<block>\; ti_3^n;l_3;\phi_3,(= a\; \ti{\<ithreetwo>}{0}) \rightarrow ti_4^m;l_4;\phi_4\; e_2^{*} \<end> : \\ ti_0^{*}\; ti_3^n;l_1;\phi_1,\ti{t}{a},(= a\; \ti{\<ithreetwo>}{0}) \rightarrow s\; ti_0^{*}\;ti_4^m;l_2;\phi_2$ by \refrule{Stack-Poly} and \refrule{Subtyping}.

        \item Case: $S;C\;{\begin{stackTL}\vdash (\<ithreetwo>.\<const> k+1) \;{\begin{stackTL}\<if>\; (ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4) \; e_1^{*}\\ \<else> e_2^{*}\\ \<end>\end{stackTL}}\\ : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2\end{stackTL}}$
        \\ $\land$ ${\begin{stackTL}
            (\<ithreetwo>.\<const> k+1) \; \<if>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e_1^{*} \<else> e_2^{*} \<end>
            \\ \hookrightarrow \<block>\; ti_3^n;l_3;\phi_3 \rightarrow ti_4^m;l_4;\phi_4 \; e_1^{*} \<end>
        \end{stackTL}}$

            This case is the same as above, except with $e_2$ instead of $e_1$ and $k+1$ instead of $0$.

        \item Case: $S;C \vdash \<label>_n \{ e^{*} \} \; v^n \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $\<label>_n \{ e^{*} \} \; v^n \<end> \hookrightarrow v^n$

            We want to show that $v^n : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$

            We first figure out what $ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ looks like.

            By \reflemma{Inversion} on \refrule{Label}, we know $ti_2^{*}=ti_1^{*}\;ti_4^{n}$.

            $S;C \vdash v^n : \epsilon;l_1;\phi_1 \rightarrow ti_4^{n};l_2;\phi_2$ because it is a premise of \refrule{Label} which we have assumed to hold.

            Now we can show that $v^n$ has the same type.

            Therefore, $S;C \vdash v^n : ti_1^{*};l_1;\phi_1 \rightarrow ti_1^{*}\;ti_4^{n};l_1;\phi_2$ by \refrule{Stack-Poly}.

        \item Case: $S;C \vdash \<label>_n \{ e^{*} \} \; \<trap> \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $\<label>_n \{ e^{*} \} \; \<trap> \<end> \hookrightarrow \<trap>$

            Trivially, $C\vdash \<trap> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ by \refrule{Trap} since $\<trap>$ accepts any precondition and postcondition.

        \item Case: $S;C \vdash \<label>_n \{ e^{*} \} \; L^j [(t.\<const> c)^n \; (\<br> j)] \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $\<label>_n \{ e^{*} \} \; L^j [(t.\<const> c)^n \; (\<br> j)] \hookrightarrow (t.\<const> c)^n \; e^{*}$

            We want to show that $v^n \; e^{*} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            Intuitively, this proof works because the premise of \refrule{Br} assumes that $C_\text{label}(i)$ is the precondition ($ti_1^n;l_3;\phi_5$, as we will soon see) of the stored instructions $e^{*}$ in the $i+1$th label, and the postcondition of the label block is immediately reachable from the postcondition of $e^{*}$.
            Meanwhile, that assumptions is ensured by \refrule{Label}, which ensures that $e^{*}$ has the same precondition as the $i+1$th branch postcondition on the label stack and the same postcondition as the label block instruction.

            By \reflemma{Inversion} on \refrule{Label}, $ti_2^{*}=ti_1^{*}\;ti_4^{*}$ for some $ti_4^{*}$.

            Also, $S;C,\text{label}(ti_1^n;l_3;\phi_5)^j \vdash (t.\<const> c)^n\; (\<br> j) : \epsilon;l_3;\phi_3 \rightarrow ti_\emptyset^{*};l_\emptyset;\phi_\emptyset$ for some $l_3$ and $\phi_3$, where $\phi_5=\phi_3,\ti{t}{a}^n,(= a\; \ti{t}{c})^n$, by \reflemma{Inversion} on \refrule{Label} and \refrule{Br}.

            Then, $S;C,\text{label}(ti_1^n;l_3;\phi_5)^j \vdash (\<br> j) : ti_1^n;l_3;\phi_5 \rightarrow ti_\emptyset^{*};l_\emptyset;\phi_\emptyset$, by \reflemma{Inversion} on \refrule{Composition} and \refrule{Const}.

            Then, $S;C,\text{label}(ti_1^n;l_3;\phi_5)^j \vdash (t.\<const> c)^n : \epsilon;l_3;\phi_3 \rightarrow ti_1^n;l_3;\phi_5$ since it is a premise of $composition$ which we have assumed to hold.

            Further, $S;C \vdash e^{*} : ti_1^n;l_3;\phi_5 \rightarrow ti_2^{*};l_2;\phi_4$ since it is a premise of \refrule{Label} which we have assumed to hold, and $\phi_4 \implies \phi_2$ by \reflemma{Inversion} on \refrule{Label}.

            Then, $S;C \vdash (t.\<const> c)^n \; e^{*} : \epsilon;l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_4$ by \reflemma{Lift-Consts} and \refrule{Composition}.

            Finally, $C \vdash (t.\<const> c)^n \; e^{*} : ti_1^{*};l_1;\phi_1 \rightarrow ti_1^{*}\;ti_4^{*};l_2;\phi_2$ by \refrule{Stack-Poly} and \refrule{Subtyping}.

        \item Case: $S;C \vdash (\<ithreetwo>.\<const> 0)\;(\<brif> j) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $(\<ithreetwo>.\<const> 0)\;(\<brif> j) \hookrightarrow \epsilon$

            In the case that $\<brif>$ does not branch, it acts exactly like $\<drop>$ (consumes $(\<ithreetwo>.\<const> 0)$ and reduces to the empty sequence).
            Thus, this case is the same as the $\<drop>$ case.

        \item Case: $S;C \vdash (\<ithreetwo>.\<const> k+1)\;(\<brif> j) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $(\<ithreetwo>.\<const> k+1)\;(\<brif> j) \hookrightarrow \<br> j$

            We want to show that $S;C \vdash \<br> j : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$

            We know $S;C \vdash \<brtable> j : ti_1^{*}\;\ti{\<ithreetwo>}{a};l_1;\phi_1,\ti{t}{a},(= a\; \ti{\<ithreetwo>}{k}) \rightarrow ti_2^{*};l_2;\phi_2$ by \reflemma{Inversion} on \refrule{Composition} and \refrule{Const}.

            Then we know $C_\text{label}(j)=(ti_3^{*};l_1;\phi_3)$, where $ti_1^{*}=ti_0^{*}\; ti_3^{*}$, $ti_2^{*} =ti_0^{*}\; ti_3^{*}$, and $\phi_1,\ti{t}{a},\neg(= a\; \ti{\<ithreetwo>}{0}) \implies \phi_3$ by \reflemma{Inversion} on \refrule{Br-Table}.

            Now we can show that $S;C \vdash \<br> j : ti_0^{*}\;ti_3^{*};l_1;\phi_1 \rightarrow ti_0^{*}\;ti_3^{*};l_2;\phi_2$.

            We have $S;C \vdash \<br> j : ti_3^{*};l_1;\phi_3 \rightarrow ti_3^{*};l_2;\phi_2$ by \refrule{Br}.

            Then, $S;C \vdash \<br> j : ti_3^{*};l_1;\phi_1,\ti{t}{a},\neg(= a\; \ti{\<ithreetwo>}{0}) \rightarrow ti_3^{*};l_2;\phi_2$, and therefore $S;C \vdash \<br> j : ti_3^{*};l_1;\phi_1,\ti{t}{a},(= a\; \ti{\<ithreetwo>}{k}) \rightarrow ti_3^{*};l_2;\phi_2$ by \refrule{Subtyping}

            Because $a$ is fresh after reduction, $\phi_1 \implies \phi_1,\ti{\<ithreetwo>}{a},(= a\; \ti{\<ithreetwo>}{k})$.

            Therefore, $C \vdash \<br> j : ti_0^{*}\;ti_3^{*};l_1;\phi_1 \rightarrow ti_0^{*}\;ti_3^{*};l_2;\phi_2$ by \refrule{Stack-Poly} and \refrule{Subtyping}.

        \item Case: $S;C \vdash (\<ithreetwo>.\<const> k)\;(\<brtable> j_1^k\; j\; j_2^{*}) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $(\<ithreetwo>.\<const> k)\;(\<brtable> j_1^k\; j\; j_2^{*}) \hookrightarrow \<br> j$

            We want to show that $S;C \vdash \<br> j : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$

            This case is similar in structure to the $(\<ithreetwo>.\<const> k+1)\;(\<brif> j)$ case.

            We know $$S;C \vdash \<brtable> j_1^k\; j\; j_2^{*} :
            {\begin{stackTL}
                ti_1^{*}\;\ti{\<ithreetwo>}{a};l_1;\phi_1,\ti{t}{a},(= a\; \ti{\<ithreetwo>}{k})
                \\ rightarrow ti_2^{*};l_2;\phi_2
            \end{stackTL}}$$ by \reflemma{Inversion} on \refrule{Composition} and \refrule{Const}.

            Then we know $C_\text{label}(j)=(ti_3^{*};l_1;\phi_3)$, where $ti_1^{*}=ti_0^{*}\; ti_3^{*}$, $ti_2^{*} =ti_0^{*}\; ti_3^{*}$, and $\phi_1,\ti{t}{a},\neg(= a\; \ti{\<ithreetwo>}{0}) \implies \phi_3$ by \reflemma{Inversion} on \refrule{Br-Table}.

            Now we can show that $S;C \vdash \<br> j : ti_0^{*}\;ti_3^{*};l_1;\phi_1 \rightarrow ti_0^{*}\;ti_3^{*};l_2;\phi_2$.

            We have $S;C \vdash \<br> j : ti_3^{*};l_1;\phi_3 \rightarrow ti_3^{*};l_2;\phi_2$ by \refrule{Br}.

            Then, $S;C \vdash \<br> j : ti_3^{*};l_1;\phi_1,\ti{t}{a},(= a\; \ti{\<ithreetwo>}{k}) \rightarrow ti_3^{*};l_2;\phi_2$ by \refrule{Subtyping}.

            Because $a$ is fresh after reduction, $\phi_1 \implies \phi_1,\ti{\<ithreetwo>}{a},(= a\; \ti{\<ithreetwo>}{k})$.

            Therefore, $C \vdash \<br> j : ti_0^{*}\;ti_3^{*};l_1;\phi_1 \rightarrow ti_0^{*}\;ti_3^{*};l_2;\phi_2$ by \refrule{Stack-Poly} and \refrule{Subtyping}.

        \item Case: $C \vdash (\<ithreetwo>.\<const> k+n)\;(\<brtable> j_1^k\; j) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $(\<ithreetwo>.\<const> k+n)\;(\<brtable> j_1^k\; j) \hookrightarrow \<br> j$

            Same as above.

        \item Case: $S;C \vdash \<call> j : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $s;\<call> j \hookrightarrow_i \<call> s_\text{func}(i,j)$

            We want to show that $\<call> s_\text{func}(i,j) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            By \reflemma{Inversion} on \refrule{Call}, we know that $l_2 = l_1$, $ti_1^{*} = ti_0^{*} \; ti_3^{*}$, $ti_2^{*} = ti_0^{*} \; ti_4^{*}$, $\phi_1 \implies \phi_3$, and $\phi_3,\phi_4 \implies \phi_2$, where $ti_3^{*};l_3;\phi_3 \rightarrow ti_4^{*};l_4;\phi_4 = C_\text{func}(j)$.

            We also know $S \vdash s_\text{inst}(i) : C$ since it is a premise of $\vdash s : S$ which we have assumed to hold.

            Then we know $S \vdash s_\text{func}(i,j) : ti_3^{*};l_3;\phi_3 \rightarrow ti_4^{*};l_4;\phi_4$ because it is a premise of $S \vdash s_\text{inst}(i) : C$.

            Therefore, $S;C\vdash \<call> s_\text{func}(i,j) : ti_3^{*};l_3;\phi_3 \rightarrow ti_4^{*};l_4;\phi_4$ by \refrule{Call-Cl}.

            Thus, $S;C\vdash \<call> s_\text{func}(i,j) : ti_0^{*}\;ti_3^{*};l_1;\phi_1 \rightarrow ti_0^{*}\;ti_4^{*};l_2;\phi_2$ by \refrule{Stack-Poly} and \refrule{Subtyping}.

        \item Case: $S;C\; {\begin{stackTL}\vdash (\<ithreetwo>.\<const> j)\; \<callindirect> ti_3^{*};l_3;\phi_3 \rightarrow ti_4^{*};l_4;\phi_4 \\: ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2\end{stackTL}}$
        \\ $\land$ $s;(\<ithreetwo>.\<const> j)\; \<callindirect> ti_3^{*};l_3;\phi_3 \rightarrow ti_4^{*};l_4;\phi_4 \hookrightarrow_i \<call> s_\text{tab}(i,j)$ where $s_\text{tab}(i,j)_\text{code}=(\<func> tfi_0\; \<local>\; t^{*}\; e^{*})$ and $tfi_0 <: ti_3^{*};l_3;\phi_3 \rightarrow ti_4^{*};l_4;\phi_4$

            We want to show that $\<call> s_\text{tab}(i,j) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            By \reflemma{Inversion} on \refrule{Composition}, \refrule{Const}, and \refrule{Call-Indirect}, we know that $ti_1^{*}=ti_0^{*}\; ti_3^{*}$ and $ti_2^{*}=ti_0^{*}\; ti_4^{*}$ for some $ti_0^{*}$, $l_1=l)2$, $\phi_1 \implies \phi_3$, and $\phi_4 \implies \phi_2$.

            We know $S \vdash s_\text{tab}(i,j) : tfi_0$ since it is a premise of $\vdash s : S$ which we have assumed to hold.

            Then, $S;C \vdash \<call> s_\text{tab}(i,j) : tfi_0$ by \refrule{Call-Cl}.

            $S;C \vdash \<call> s_\text{tab}(i,j) : ti_3^{*};l_1;\phi_3 \rightarrow ti_4^{*};l_2;\phi_4$ by \refrule{Subtyping}.

            Therefore, $S;C \vdash \<call> s_\text{tab}(i,j) : ti_0^{*}\;ti_1^{*};l_1;\phi_1 \rightarrow ti_0^{*}\;ti_1^{*};l_2;\phi_2$ by \refrule{Stack-Poly}.

        \item Case: $S;C \vdash (\<ithreetwo>.\<const> j)\; \<callindirect> tfi : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $s;(\<ithreetwo>.\<const> j)\; \<callindirect> tfi \hookrightarrow_i \<trap>$.

            Trivially, $S;C \vdash \<trap> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ by \refrule{Trap}.

        \item Case: $S;C \vdash v^n\; \<call> cl : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $s;v^n\; \<call> cl \hookrightarrow_i {\begin{stackTL}
            \<local>_m \;
            {\begin{stackTL}
                \{ i;v^n \; (t.\<const> 0)^k \}
                \\ \<block>\;
                {\begin{stackTL}
                    ({\begin{stackTL}\epsilon;ti_3^{n}\;\ti{t}{a}^{n};\phi_3,\ti{t}{a}^k,(= a \;\ti{t}{0})^k \\\rightarrow ti_4^{m};l_4;\phi_4)\end{stackTL}}
                    \\ e^{*}
                \end{stackTL}}
                \\ \<nsend>
            \end{stackTL}}
            \\ \<end>
        \end{stackTL}}$
        \\ where $cl_\text{code} = \<func> (ti_3^{n};\epsilon;\phi_3 \rightarrow ti_4^{m};l_4;\phi_4)\; \<local>\; t^k \; e^{*}$ and $cl_\text{inst} = i$

            Let
            \begin{mathpar}
                \begin{array}{rcl}
                tfi_0 &=& ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$,$ \\
                tfi_1 &=& \epsilon;ti_3^{n}\;\ti{t}{a}^{n};\phi_3,\ti{t}{a}^k,(= a \;\ti{t}{0})^k \rightarrow ti_4^{m};l_4;\phi_4$, and$ \\
                tfi_2 &=& ti_3^{n};\epsilon;\phi_3 \rightarrow ti_4^{m};l_4;\phi_4 \\
                \end{array}
            \end{mathpar}

            We want to show that
            $$S;C \;
            {\begin{stackTL}
                \vdash_i
                {\begin{stackTL}
                    \<local>_m \;
                    {\begin{stackTL}
                        \{ i;v^n \; (t.\<const> 0)^k \}
                        \\ \<block>\; \epsilon;ti_3^{n}\;\ti{t_2}{a_2}^{n};\phi_3 \rightarrow ti_4^{m};l_4;\phi_4 \; e^{*} \<end>
                    \end{stackTL}}
                    \\ \<end>
                \end{stackTL}}
                \\ : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2
            \end{stackTL}}$$

            By \reflemma{Inversion} on \refrule{Composition}, \refrule{Const}, and \refrule{Call-Cl}, we know $l_2=l_1$, $ti_2^{*}=ti_1^{*}\;ti_4^m$, $\phi_1,\ti{t_2}{a_2},(\<eq> a_2 \; \ti{t_2}{c}) \implies \phi_3$, $\phi_4 \implies \phi_2$, and $S\vdash cl : tfi_1$.

            We also know that $$S;C \vdash (t_2.\<const> c)^n : ti_1^{*};l_1;\phi_1 \rightarrow ti_1^{*}\;ti_5^n;l_1;\phi_1,\ti{t_2}{a_2},(= a_2 \; \ti{t_2}{c})$$
            where $v^n=(t_2.\<const> c)^n$, and
            $$S;C\vdash \<call> cl : ti_1^{*}\;ti_5^n;l_1;\phi_1,\ti{t_2}{a_2}^{n},(= a_2 \; \ti{t_2}{c})^{n} \rightarrow ti^{*}\;ti_2^m;l_2;\phi_2$$ because they are premises of \refrule{Composition} which we have assumed to hold.

            We have $C \vdash \<func> tfi_2\; \<local>\; t^k \; e^{*} : tfi_2$ because it is a premise of $S \vdash cl : tfi_2$.

            Then, $$S;C,\text{local } t_2^n\; t^k,\text{label }(ti_4^{m};l_4;\phi_4),\text{return }(ti_4^{m};l_4;\phi_4) \vdash e^{*}: tfi_1$$ because it is a premise of the above derivation.

            We can now reconstruct the type after reduction.

            $S;C,\text{local } t_2^n\; t^k,\text{return }(ti_4^{m};l_4;g_4;\phi_4) \vdash \; \<block>\; tfi_1\; e^{*} \<end> : tfi_1$ by \refrule{Block}.

            $\vdash v : \ti{t_2}{a_2} ;\circ,\ti{t_2}{a_2},(\<eq> a_2 \; \ti{t_2}{c}))^n$ by \refrule{Admin-Const}, and $(\vdash (t \<const> 0) : \ti{t}{a};\circ,\ti{t}{a},(\<eq> a \; \ti{t}{0}))^k$ by \refrule{Admin-Const}.

            Then, $S;(ti_4^{m};l_4;\phi_4)\; \vdash v^n \; (t \<const> 0)^k;\<block>\; tfi_2\; e^{*} \<end> :  ti_4^{m};l_4;\phi_4$ by \refrule{Code}.

            Recall that $\phi_4 \implies \phi_2$.

            Then, $S;(ti_4^{m};l_4;\phi_4)\; \vdash v^n \; (t \<const> 0)^k;\<block>\; tfi_2\; e^{*} \<end> :  ti_4^{m};l_4;\phi_2$ by \refrule{Subtyping}.

            $S;C \vdash \<local>_m\{j;v^n \; (t.\<const> 0)^k\} \; \<block>\; tfi_2\; e^{*} \<end> \<end> : \epsilon;l_1;\phi_1 \rightarrow \epsilon\;ti_4^m;l_1;\phi_1,\phi_2$ by \refrule{Local}.

            $S;C \vdash \<local>_m\{j;v^n \; (t.\<const> 0)^k\} \; \<block>\; tfi_2\; e^{*} \<end> \<end> : tfi_0$ by \refrule{Stack-Poly}.

        \item Case: $S;C \vdash \<local>_n \{ i;v_l^{*} \} \; \<trap> \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $\<local>_n \{ i;v_l^{*} \} \; \<trap> \<end> \hookrightarrow \; \<trap>$

            Trivially, $S;C \vdash \<trap> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ by \refrule{Trap}.

        \item Case: $S;C \vdash \<local>_n \{ i;v_l^{*} \} \; L^k[(t.\<const> c)^n \; \<return>] \<end> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $\<local>_n \{ i;v_l^{*} \} \; L^k[(t.\<const> c)^n \; \<return>] \<end> \hookrightarrow_j \; (t.\<const> c)^n$

            We want to show that $(t.\<const> c)^n : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$

            This proof is similar to the $\<br>$ case above, but with a few extra steps.

            First, we derive the type of $(t.\<const> c)^n$ from the precondition of $\<return>$.

            $ti_2^{*} = ti_1^{*} \; ti^n$, $l_1 = l_2$,
            $S;(ti_3^n;l_2;\phi_3) \vdash_i v_l^{*};L^k[(t.\<const> c)^n \; \<return>] : ti_3^n;l_2;\phi_3$,
            and $\phi_1,\phi_3 \implies \phi_2$ by \reflemma{Inversion} on \refrule{Local}.

            $(\vdash v_l : ti_l;\phi_l)^{*}$ and $S;C_l \vdash L^k[(t.\<const> c)^n \; \<return>] : \epsilon;ti_l^{*};\phi_l^{*} \rightarrow ti^n;l_3;\phi_3$,
            where $C_l = S_\text{inst}(i),\text{local} \; t^{*}, \text{return} \; (ti^n;l_3;\phi_3)$,
            because they are premises of \refrule{Code} that we have assumed to hold.

            $ti_l^{*} = \ti{t_l}{a_l}^{*}$ because it is a premise of \refrule{Admin-Const} which we have assumed to hold.

            By \reflemma{Inversion} on \refrule{Composition} and \refrule{Return},
            $S;C_l \vdash (t.\<const> c)^n : ti_4^{*};l_4;\phi_4 \rightarrow ti_3^n;l_3;\phi_3$,
            and $S;C_l \vdash \<return> : ti_3^n;l_3;\phi_3 \rightarrow ti_\emptyset^{*};l_\emptyset;\phi_\emptyset$.

            By \reflemma{Inversion} on \refrule{Const}, $l_4 = l_3$
            and $\phi_4,\ti{t}{a}^n,(= a\; \ti{t}{c})^n \implies \phi_3$.

            Now we can show that $(t.\<const> c)^n : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$

            We have $S;C \vdash (t.\<const> c)^n : \epsilon;l_3;\phi_4 \rightarrow ti_3^n;l_3;\phi_4,\ti{t}{a}^n,(= a\; \ti{t}{c})^n$ by \refrule{Const}.

            Then, $S;C \vdash (t.\<const> c)^n : \epsilon;ti_l^{*};\phi_l^{*} \rightarrow ti_3^n;l_3;\phi_4,\ti{t}{a}^n,(= a\; \ti{t}{c})^n$ by \reflemma{Lift-Consts}.

            By \reflemma{Inversion} on \refrule{Const}, $\phi_l^{*} \implies \phi_4$.
            Further, since $a_l^{*}$ are fresh, $\circ \implies \phi_l^{*}$.

            Thus, $S;C \vdash (t.\<const> c)^n \epsilon;ti_l^{*};\circ \rightarrow ti_3^n;l_3;\phi_4,\ti{t}{a}^n,(= a\; \ti{t}{c})^n$ by \refrule{Subtyping}.

            We know then that $\ti{t}{a}^n,(= a\; \ti{t}{c})^n \implies \phi_4,\ti{t}{a}^n,(= a\; \ti{t}{c})^n$ by \reflemma{Inversion} on \refrule{Const}, and therefore that $\phi_4$ only contains constraints on fresh variables.

            Then, $S;C \vdash (t.\<const> c)^n : \epsilon;l_1;\phi_1 \rightarrow ti_3^n;l_1;\phi_1,\ti{t}{a}^n,(= a\; \ti{t}{c})^n$ by \refrule{Const}.

            Then, $S;C \vdash (t.\<const> c)^n : \epsilon;l_1;\phi_1 \rightarrow ti_3^n;l_2;\phi_1,\phi_4,\ti{t}{a}^n,(= a\; \ti{t}{c})^n$, $S;C \vdash (t.\<const> c)^n : \epsilon;l_1;\phi_1 \rightarrow ti^n;l_2;\phi_1,\phi_3$, and finally $S;C \vdash (t.\<const> c)^n : \epsilon;l_1;\phi_1 \rightarrow ti^n;l_2;\phi_2$ by \refrule{Subtyping}.

            Therefore, $S;C \vdash (t.\<const> c)^n : ti_1^{*};l_1;\phi_l^{*} \rightarrow ti_2^{*};l_2;\phi_2$ by \refrule{Stack-Poly}.

        \item Case: $S;C \vdash v \; (\<teelocal> j) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$
        \\ $\land$ $v \; (\<teelocal> j) \hookrightarrow v\;v\;(\<setlocal> j)$

            Note: We can include $\<teelocal>$ here because it does not actually need to reason about locals since it gets reduced to a $\<setlocal>$, so we only have to do the reasoning in the $\<setlocal>$ case.

            We want to show that $v\;v\;(\<setlocal> j) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            As usual, we start by figuring out what $ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ looks like.

            By \reflemma{Inversion} on \refrule{Composition}, we know that
            $S;C \vdash v : ti_1^{*};l_1;\phi_1 \rightarrow ti_3^{*};l_3;\phi_3$,
            and $S;C \vdash \<teelocal> j : ti_3^{*};l_3;\phi_3 \rightarrow ti_2^{*};l_2;\phi_2$.

            By \reflemma{Inversion} on \refrule{Tee-Local}, we also know that
            $ti_3^{*} = ti^{*} \; \ti{t}{a}$, $ti_2^{*} = ti^{*} \; \ti{t}{a_2}$, $l_2 = l_3[j := \ti{t}{a}]$,
            and $\phi_3,\ti{t}{a_2},(= a_2\;a) \implies \phi_2$.

            Then, by \reflemma{Inversion} on \refrule{Const},
            $t.\<const> c = v$, $ti_1^{*} = ti^{*}$, $l_3 = l_1$,
            and $\phi_1,\ti{t}{a},(= a\;\ti{t}{c}) \implies \phi_3$.

            Now, we can show that $v\;v\;(\<setlocal> j) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

            We have $S;C \vdash v\;v : \epsilon;l_1;\phi_1 \rightarrow \ti{t}{a_2}\;\ti{t}{a};l_1;\phi_1,\ti{t}{a_2},(= a_2\;\ti{t}{c}),\ti{t}{a},(= a\;\ti{t}{c})$ by \refrule{Const}.

            We also have $\ti{t}{a_2},(= a_2\;\ti{t}{c}),\ti{t}{a},(= a\;\ti{t}{c}) \implies \ti{t}{a_2},(= a_2\;a),\ti{t}{a},(= a\;\ti{t}{c})$ by $\implies$.

            Then, $S;C \vdash v\;v : \epsilon;l_1;\phi_1 \rightarrow \ti{t}{a_2}\;\ti{t}{a};l_1;\phi_2$ by \refrule{Subtyping}.

            We have $S;C \vdash \<setlocal> j : \ti{t}{a};l_1;\phi_2 \rightarrow \epsilon;l_1[j := \ti{t}{a}];\phi_2$ by \refrule{Set-Local}.

            Therefore, $S;C \vdash v\;v\;(\<setlocal> j) : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ by \refrule{Composition} and \refrule{Stack-Poly}.
    \end{itemize}
\end{proof}
