\chapter{\name}
\label{chp:prechk}
The goal of \name is to be used to eliminate unnecessary dynamic checks.
To accomplish this, it must be able to (1) facilitate removing dynamic checks on instructions and (2) statically prove that certain instructions do not require dynamic checks.
In \name, we extend \wasm with new instructions that explicitly do not require dynamic checks, and design an indexed type system to reason about the safety of removing checks.

\section{\name Syntax}
The syntax of \name is highly similar to that of \wasm except for two additions.
First, \name introduces four additional instructions, which are referred to as ``\prechk-tagged'' instructions.
Second, \name changes the representation of types within \wasm instructions and functions.

\subsection{\prechk-tagged Instructions}
There are four \wasm instructions that require run-time checks (see \ref{subsec:wasmsemantics}).
``\prechk-tagged'' instructions refer to a set of four \name instructions, listed in \ref{fig:newinstructions}, that are counterparts to these four \wasm instructions.
Intuitively, we are simply adding a tag to the instruction to show that it doesn't require run-time checks.
Formally, however, these are different instructions with different semantics and different typing rules, as explained below.

\begin{figure}[t]
    \begin{align*}
        &t.\<divpc> \mid
        t.\<callindirectpc> \mid
        \\
        &t.\<loadpc> (tp\_sx)^{?}\; a\;o \mid
        t.\<storepc> tp^{?\;} a\;o
    \end{align*}
    \caption{The four \prechk-tagged instructions}
    \label{fig:newinstructions}
\end{figure}

\subsection{The \name Index Language}
\name uses an indexed type system.
An indexed type language uses an index language in the type system to encode information within types.
We use the index language to encode linear constraints on program variables within types.
Figure~\ref{fig:itsyntax} shows the syntax for the index type language.
Syntax written in a \tbbf{blue, bold font} denotes a \wasm keyword.
Below is a quick overview of each of the terms.

\begin{figure}[t]
    \begin{math}
        \begin{array}{rcl}
            t &:: & \<ithreetwo> \mid \<isixfour> \\
            a &::= & Var \\
            x\;y &::=& a \mid \ti{t}{c} \mid (\<binop>\;x\;y) \mid (\<testop>\;x) \mid (\<relop>\;x\;y) \\
            P &::=& (=\; x \; y) \mid (if\; P\; P\; P) \mid \neg P \mid P \land P \mid P \lor P \\
            \phi &::=& \circ \mid \phi, \ti{t}{a} \mid \phi, P \\
        \end{array}
    \end{math}
    \caption{Syntax of the \name index type language}
    \label{fig:itsyntax}
\end{figure}

\begin{itemize}
    \item $t$ represents a primitive \wasm type.
    We do not reason about floating points, so it is either a 32-bit integer ($i32$) or a 64-bit integer ($i64$).
    \item $a$ is a type index variable, which is used to track constraints on program variables.
    \item $x$ and $y$ are type indices, they can be an index type variable, a constant with an explicit type, or a \wasm operation on a type index.
    \item $P$ is a proposition about type indices which can encode equality constraints on type indices, or combine propositions using common first-order logic operators.
    \item $\phi$ is the type index context which stores index type variable declarations and propositions.
\end{itemize}

In \name, we extend \wasm's technique for handling the stack to include an index context $\phi$ (which contains type index variable declarations and the constraints on indices) and the index types of local and global variables (similar to the Register file in \dtal) in the precondition and postcondition.

The index local store associates index variables with \wasm local variables.
It has an identical form to the stack (a list of indexed types to associate index variables with local variables).
We use the shorthand $l$ to refer to the index local store since we rarely reason about it but rather thread it through typing rules.
The index type context $\phi$ is the mechanism that is used to reason about the possible values of computations
It stores constraints on and between program variables tracked by indexed types representing the stack and index local store.

In the \name type system, the shape of the stack is represented by indexed types, $ti ::= \ti{t}{a}$, which include both the expected \wasm type $t$, and the index variable $a$ that is associated with the value on the stack.
Further, the precondition and postcondition of function types are extended to include the index local store $l$ and the index type context $\phi$.
We refer to these extended function types as indexed function types: $tfi ::= ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.
Certain \wasm instructions (such as $\<block>$, $\<loop>$, and $\<if>$), include \wasm function types to declare the expected types of their bodies.
In \name, we replace those function types with indexed function types.

We retain $C$ to refer to the module type context in \name, except that we replace \wasm function types with \name indexed function types, and replace the postcondition types in the label stack and return stack with \name indexed postcondition types.

\section{\name Semantics}
The formal reason certain \wasm instructions require run-time checks is because they have preconditions as part of their semantics, and if the preconditions are not met then those instructions trap to avoid undefined behavior.
The \wasm type system is not expressive enough to ensure these preconditions statically, so they instead must be checked at run-time.
Conversely, ``\prechk-tagged'' instructions can assume that the preconditions on their behavior hold because it is enforced by the \name type system.
This can be seen in the reduction rules for the ``\prechk-tagged'' instructions in Figure \ref{fig:prechkredux}, where they do not have rules to trap when their preconditions do not hold.

\label{sec:newinstructions}
\begin{figure}[t]
    \todo{This display sucks cause it just can't fit on the page :(}
    \begin{math}
        \arraycolsep=1.4pt
        \begin{array}{rcl}
            (t.\<const> c_1)\;(t.\<const> c_2) && \\
            t.\<divpc> & \hookrightarrow & c \\
            && \text{if } c_2 \neq 0 \land c=c_1/c_2 \\
            s;(t.\<const> j) && \\
            t.\<callindirectpc> & \hookrightarrow_i & \<call> s_{tab}(i,j) \\
            &&\text{if } s_{tab}(i,j) = \\
            && \<func> tfi\; \<local>\; t^{*}\;e^{*} \\
            s;(\<ithreetwo>.\<const> k) && \\
            (t.\<loadpc> (tp\_sx)^{?}\; a\;o) & \hookrightarrow_i & t.\<const> const_t(b^{*}) \\
            && \text{if } s_{mem}(i,k+o,|t|)=b^{*} \\
            s;(\<ithreetwo>.\<const> k)\;(t.\<const> c) && \\
            (t.\<storepc> tp^{?}\; a\;o) & \hookrightarrow_i & s';\epsilon \\
            && \text{if } s'=s \\
            && \text{with mem}(i,k+o,|t|)=bits_t^{|t|}(c) \\
        \end{array}
    \end{math}
    \caption{Behavior of new \prechk-tagged instructions}
    \label{fig:prechkredux}
\end{figure}

All other \name instructions have equivalent semantics to their \wasm versions.

\section{The \name Indexed Type System}
\label{sec:typesys}
The \name type system is designed to provide sufficient information to safely eliminate dynamic checks (\ie to ensure that the required preconditions are met to \prechk-tag an instruction).
It is based on the type system from \dtal, which is capable of ensuring similar properties to those we desire to prove.
For most instructions with 

\name can currently eliminate checks for four types of instructions: memory loads and stores (similar to \dtal), integer division, and indirect function calls.
Tagging memory loads and stores with \prechk requires ensuring that the memory index is valid.
The integer division instruction can be \prechk tagged if the second argument is provably non-zero.
Indirect function calls are a particularly interesting case that is specific to \wasm: they are used to safely handle function pointers when compiling from C/C++ and require a dynamic check to ensure that the called function has a suitable type.
Proving the safety of an indirect function call involves showing that every possible function that could be called will not cause a run-time type error.

Integer division simply requires that the second argument is non-zero.
For example, the second rule in Figure \todo{figure} ensures that pre-checked division instructions can be safely executed.
The premise $\phi \implies (neq\ b\ 0)$ requires that the index constraints satisfy the proposition $b \neq 0$ for the pre-checked instruction to be safe.
Therefore, since a divide-by-zero is provably absent, it is safe to replace the division operator instruction with the \prechk-tagged version.

\begin{mathpar}
\inferrule[]{ }{ %% binop
    \typerule{t.binop} {
        \insttype{\type{\ti{t}{a_1}\ti{t}{a_2}}{l}{\phi}}
                {\type{\ti{t}{a_3}}{l}{\phi,\ti{t}{a_3},(= a_3\;(binop\;a_1\;a_2))}
        }
    }
}
\end{mathpar}


\subsection{Subtyping, Implication, and Constraint Satisfaction}
One issue with adding the index type context $\phi$ to preconditions and postconditions is that the postcondition of one instruction and the precondition of the next instruction might not match up exactly.
For example, one instruction may ensure a value is greater than ten, but the next just wants the value to be greater than zero.
Intuitively, if a value, ``x'', is greater than ten it must also be greater than zero, and we want the \name type system to be able to figure this out as well.
However, computers as of yet are unable to use intuition, so we must instead formalize this intuition such that a computer can reason about it.

Our formalization of this problem is based on Hoare logic \todo{find proper citation}.
Hoare logic similarly has preconditions and postconditions on statements, and allows those preconditions to be \emph{strengthened} and postconditions to be \emph{weakened}.
Strengthening and weakening is based on implication ($\implies$).
We say that $\phi_1 \implies \phi_2$ when the following holds: if $\phi_1$ is satisfied, then $\phi_2$ must also be satisfied.
If $\phi_1 \implies \phi_2$, then we consider $\phi_1$ to be stronger than $\phi_2$, and $\phi_2$ to be weaker than $\phi_1$.
This solves the aforementioned problem because we can weaken ``x is greater than 10'' to ``x is greater than 0'' (or equivalently strengthen ``x is greater than 0'' to ``x is greater than 10'').

In practice, we reason about implication using the Z3 theorem prover \todo{citation needed}.
To test whether the satisfiability of one index type context $\phi_1$ implies that some other index type context $\phi_2$ is satisfiable, we first generate Z3 constraints based on the propositions in both contexts.
Then, we assert that the constraints generated for the first context must hold.
Finally, we ask Z3 to find an assignment to the variables declared in the type index contexts where the constraints from the second context do not hold (a counterexample).
If a counterexample cannot be found then the implication must hold, otherwise it does not hold.

\todo{Need to format the digression to set it apart}
\thought{Maybe this is better moved to the discussion section to discuss as part of the implementation?}
\paragraph{Digression about impact of using Z3.}
Our choice of using Z3 has impacted \name in several ways.
\begin{itemize}
    \item The biggest impact is that we currently do not supporting floating point values and certain unary and binary operators because Z3 is unable to reason about them.
    \item Because of how we test implication, we require that the index type contexts use the same names to refer to the same index variables.
    \item The requirement of adding explicit type annotations for index variables and constants that appear in type indices comes from needing to know what width the variable will be when we convert it to a Z3 bitvector.
\end{itemize}

\todo{End of digression}

To fit strengthening and weakening into the type system, we define a subtyping judgment based on implication.
The subtyping judgement says that if an indexed function type $tfi_1$ has a stronger precondition and weaker postcondition than some other indexed function type $tfi_2$, and is otherwise equivalent, then $tfi_1$ is a subtype of $tfi_2$:

\[
    \inferrule{
        \phi_0 \implies \phi_1 \and
        \phi_2 \implies \phi_3
    }{
        ti_1^{*};l_1;\phi_0 \rightarrow ti_2^{*};l_2;\phi_3 <: ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2
    }
\]

We then use this in the \name type system by adding a typing rule that allows the indexed function type for a list of instructions to be replaced by a subtype of that indexed function type:

\[
    \inferrule{
        ti_1^{*};l_1;\phi_0 \rightarrow ti_2^{*};l_2;\phi_3 <: ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2 \\
        C \vdash e^{*} \rightarrow ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2
    }{
        C \vdash e^{*} \rightarrow ti_1^{*};l_1;\phi_0 \rightarrow ti_2^{*};l_2;\phi_3
    }
\]
