\subsection{Embedding \wasm in \name}
\label{subsec:embedding}
We present a way to embed \wasm programs in \name.
The embedding function takes a \wasm program and replaces all of the type annotations with indexed function types that have no constraints on the variables.
Intuitively, this is the only part of the surface syntax of \wasm that isn't in \name, so we must figure out a way to bring it over.
While this embedding requires no additional developer effort, it provides no information to the indexed type system beyond what can be inferred from the instructions in the program.
We conjecture that a well typed \wasm program embedded in \name is also well typed, but we have not proved it.

We typeset \name instructions in a \tbsf{blue sans serif font} and \wasm instruction in a \trbf{bold red font} to set them apart.

\begin{conjecture}{Well Typed \wasm Programs Embedded in \name are Well Typed}

    If $\vdash \<wmodule> f^{*}\;glob^{*}\;tab^{?}\;mem^{?}$,
    \\then $\vdash \embed[module]{\<wmodule> f^{*}\;glob^{*}\;tab^{?}\;mem^{?}}$
\end{conjecture}

In order to support embedding of both local and imported functions we need a syntactic way of extracting the type annotation from the function.

\begin{definition}{\fbox{$annotation(f)=\tfi$}}
    \begin{mathpar}
        \begin{array}{rcl}
            annotation(ex^{*}\; \<func> \tfi\; \<local>\; t^{*}\; e^{*})
            &=& \tfi\\
            annotation(ex^{*}\; \<func> \tfi\; im)
            &=& \tfi\\
        \end{array}
    \end{mathpar}
\end{definition}

Embedding works purely over the surface syntax of the languages.
As such, we define embedding over modules: the pinnacle syntactic objects of both the \wasm and \name surface syntax hierarchies.
Embedding a module $module$ means embedding all of the functions $f^{*}$ in the module, and embedding the table $tab$ parameterized with all of the function definitions $f^{*}$.
We do not have to embed globals $glob^{*}$ or the memory $mem^{?}$ as they have the same syntax in both \wasm and \name.
We explain how to embed tables $tab$ in \autoref{def:embed-t}, and functions $f$ in \autoref{def:embed-f}.

\begin{definition}{\fbox{$\embed[module]{module}=\mathbluesf{module}$}}
    \label{def:embed-m}
    \begin{mathpar}
        \begin{array}{rcl}
            embed_{module}(\<wmodule> f^{*}\; glob^{*}\; tab^{?}\; mem^{?})
            &=& \<module>
            \begin{stackTL}
                \embed[f]{f}^{*}
                \\ glob^{*}
                \\ \embed[tab]{tab^{?}}^{annotation(f)^{*}}
                \\ mem^{?}
            \end{stackTL} \\
        \end{array}
    \end{mathpar}
\end{definition}

Tables in \name must also provide the indexed function types of all the functions they contain, so to embed them we must include those types.
We do this by parameterizing the embedding of the table $tab$ with all of the function types $\tfi^{*}$.
Then, we retrieve the indexed function type $ti_1;l_1;\phi_1 \rightarrow ti_2;l_2;\phi_2$ of the function pointed to by the function index $i$ in $\tfi^{*}$ for every function index $i$ in the table.
We cannot embed imported tables because we have no way of accessing the types of the functions included in the table.

\begin{definition}{\fbox{$\embed[tab]{tab}^{\tfi^{*}}=\mathbluesf{tab}$}}
    \label{def:embed-t}
    \begin{mathpar}
        \begin{array}{rcl}
            embed_{tab}(ex^{*}\; \<wtable> n\; i^{n})
            &=& ex^{*}\; \<table> n\; (ti_1;\epsilon;\phi_1 \rightarrow ti_2;\epsilon;\phi_2)^{n} \\
            && \text{where } \forall i. \tfi^{*}(i) = ti_1;\epsilon;\phi_1 \rightarrow ti_2;\epsilon;\phi_2
        \end{array}
    \end{mathpar}
\end{definition}

The embedding of functions, \autoref{def:embed-f}, both must construct an indexed function type for itself and embed its body.
Function bodies have their local variables defined by the function that they are enclosed in.
Thus, when the function body is embedded we pass the local types ($t_1^{*}\;t^{*}$) so the body knows how to constrain local variables.
We construct an indexed function type that has the precondition of the expected values on the stack turned into indexed types using fresh index variables and the types $t_1^{*}$ from the \wasm type, and do the same with the postcondition and $t_2^{*}$.

\begin{definition}{\fbox{$\embed[f]{f}=\mathbluesf{f}$}}
    \label{def:embed-f}
    \begin{mathpar}
        \begin{array}{rcl}
            embed_f(ex^{*}\; \<wfunc>
            \begin{stackTL}
                (t_1^{*} \rightarrow t_2^{*})
                \\ \<wlocal>\; t^{*}\; e^{*})
            \end{stackTL}
            &=& ex^{*}\; \<func>\;
                \begin{stackTL}
                    (\ti{t_1}{a_1}^{*};\epsilon;(\circ,\ti{t_1}{a_1}^{*})
                    \\ \rightarrow
                    \ti{t_2}{a_2}^{*};\epsilon;(\circ,\ti{t_2}{a_2}^{*}))
                    \\ \<local>\; t^{*}\; (\embed[e]{e}^{(t_1^{*}\;t^{*})})^{*}
                \end{stackTL}\\
            embed_f(ex^{*}\; \<wfunc> (t_1^{*} \rightarrow t_2^{*})\; im)
            &=& ex^{*}\; \<func>\;
                \begin{stackTL}
                    (\ti{t_1}{a_1}^{*};\epsilon;(\circ,\ti{t_1}{a_1}^{*})
                    \\ \rightarrow
                    \ti{t_2}{a_2}^{*};\epsilon;(\circ,\ti{t_2}{a_2}^{*}))
                    \\ im
                \end{stackTL}\\
        \end{array}
    \end{mathpar}
\end{definition}

Embedding instructions replaces all function types used within the \wasm syntax with \name indexed function types, and adds the function types for all of the functions in a table to the table's type declaration.
This occurs within blocks and indirect function calls, as shown in \autoref{def:embed-e}.
The indexed types simply have fresh index variables that are different in the precondition and postcondition, and the primitive types for the stack are known from the \wasm type $t_1^{*} \rightarrow t_2^{*}$.
To know what the local variables are, we parameterize the embedding over the types of local variables ($t^{*}$).

\begin{definition}{\fbox{$\embed[e]{e}^{t^{*}}=\mathbluesf{e}$}}
    \label{def:embed-e}
    \begin{mathpar}
        %% SPACE HACKS
        \arraycolsep=2pt
        \begin{array}{rcl}
            embed_{e^{*}}({\begin{stackTL}
                \<wblock>
                {\begin{stackTL}
                    (t_1^{*} \rightarrow t_2^{*})\;
                    \\e^{*}
                \end{stackTL}}\\
            \<wend>)^{t^{*}}
            \end{stackTL}}
            &=& {\begin{stackTL}
                    \<block>
                    \\ \quad (\ti{t_1}{a_1}^{*};\ti{t}{a_3}^{*};(\circ,\ti{t_1}{a_1}^{*},\ti{t}{a_3}^{*})
                    \\ \quad\; \rightarrow \ti{t_2}{a_2}^{*};\ti{t}{a_4}^{*};(\circ,\ti{t_2}{a_2}^{*},\ti{t}{a_4}^{*}))
                    \\ \quad \embed[e^{*}]{e^{*}}^{t^{*}}
            \end{stackTL}} \\
            && \<nsend>\\

            embed_{e^{*}}({\begin{stackTL}
                \<wloop>
                {\begin{stackTL}
                    (t_1^{*}\rightarrow t_2^{*})\;
                    \\e^{*}
                \end{stackTL}}\\
            \<wend>)^{t^{*}}
            \end{stackTL}}
            &=& {\begin{stackTL}
                    \<loop>
                    \\ \quad (\ti{t_1}{a_1}^{*};\ti{t}{a_3}^{*};(\circ,\ti{t_1}{a_1}^{*},\ti{t}{a_3}^{*})
                    \\ \quad\; \rightarrow \ti{t_2}{a_2}^{*};\ti{t}{a_4}^{*};(\circ,\ti{t_2}{a_2}^{*},\ti{t}{a_4}^{*}))
                    \\ \quad \embed[e^{*}]{e^{*}}^{t^{*}}
            \end{stackTL}} \\
            && \<nsend>\\

            embed_{e^{*}}({\begin{stackTL}
                \<wif>
                {\begin{stackTL}
                    (t_1^{*}\rightarrow t_2^{*})\;
                    \\e^{*}
                \end{stackTL}}\\
            \<wend>)^{t^{*}}
            \end{stackTL}}
            &=& {\begin{stackTL}
                    \<if>
                    \\ \quad (\ti{t_1}{a_1}^{*};\ti{t}{a_3}^{*};(\circ,\ti{t_1}{a_1}^{*},\ti{t}{a_3}^{*})
                    \\ \quad\; \rightarrow \ti{t_2}{a_2}^{*};\ti{t}{a_4}^{*};(\circ,\ti{t_2}{a_2}^{*},\ti{t}{a_4}^{*}))
                    \\ \quad \embed[e]{e_1^{*}}^{t^{*}}\; \embed[e]{e_2^{*}}^{t^{*}}
                \end{stackTL}} \\
            && \<nsend>\\

            embed_{e^{*}}(
                {\begin{stackTL}
                    \<wcallindirect>
                    \\\quad (t_1^{*}\rightarrow t_2^{*}))^{t^{*}}
                \end{stackTL}}
            &=& {\begin{stackTL}
                \<callindirect>
                \\ \quad (\ti{t_1}{a_1}^{*};\ti{t}{a_3}^{*};(\circ,\ti{t_1}{a_1}^{*},\ti{t}{a_3}^{*})
                \\ \quad\; \rightarrow \ti{t_2}{a_2}^{*};\ti{t}{a_4}^{*};(\circ,\ti{t_2}{a_2}^{*},\ti{t}{a_4}^{*}))
            \end{stackTL}} \\

            \embed[e^{*}]{e}^{t^{*}} &=& e \text{, otherwise} \\
            \embed[e^{*}]{e^{*}}^{t^{*}} &=& (\embed[e^{*}]{e}^{t^{*}})^{*} \\
        \end{array}
    \end{mathpar}
\end{definition}

These are not the only differences in the surface syntax between \wasm and \name: we also introduced four new instructions (the \prechk-tagged instructions).
The definition of embedding we have introduced has been entirely syntactic, but that will not work for replacing non-\prechk-tagged instructions with \prechk-tagged versions during embedding since we must be able to ensure that stronger guarantees are met.
Instead, one could, for example, check at every $\<div>$, $\<callindirect>$, $\<load>$, and $\<store>$ whether the \prechk-tagged version of the instruction is welltyped, and only if it is well typed replace the instruction with the \prechk-tagged version.
However, a more sophisticated static analysis could be able to provide more precise type annotations and therefore potentially allow even check eliminations.

Want to prove that the embedding produces well-typed \name, embedding works on a module level, so the proof should be done on a module level.


\begin{theorem}{Sound Module Typing Embedding}
    \label{thm:moduleembedding}

    If $\vdash \<wmodule> f^{*}\;glob^{*}\;tab^{?}\;mem^{?}$ and
    $tab = (ex_t^{*}\; \<wtable> n\; i^n)$,
    \\ then $\vdash \embed[module]{\<wmodule> f^{*}\;glob^{*}\;tab^{?}\;mem^{?}}$
\end{theorem}
\begin{proof}

    Note that the globals $glob^{*}$ and memory $mem^{?}$ are not affected by embedding, and have the same module typing rules in \wasm as in \name.
    Thus, we only need to reason about the functions $f^{*}$ and table $tab^{?}$.

    % 1. Instantiate premises of WASM module.
    $(C_w \vdash f : ex_f^{*}\; \tf)^{*}$, where
    $C_w = \{ \text{func } \tf^{*},\; \text{global } tg^{*},\; \text{table } n^{?},\; \text{memory } n^{?} \}$
    since they are premises of WASM module.

    % 2. Instantiate the structure of the function embeddings. This gets us the type annotations of the functions.
    $(annotation(\embed[f]{f}) = \tfi)^{*}$.

    % 3. Construct the table types from the function annotations and i. (2)
    Let $\tfi_t = (\forall i. \tfi^n(i))^{?}$.

    % 4. Construct the context for the embeddings. (2, 3)
    Let $C_p = \{ \text{func } \tfi^{*}, \text{global } tg^{*}, \text{table } (n,\tfi_t^n)^{?}, \text{memory } n^{?} \}$.

    % 5. Instantiate the table embedding, using the definition of tfi_t above. (3)
    $\embed[tab]{tab^{?}}^{\tfi^{*}} = (ex_t^{*}\; \<table> n\; \tfi_t^n)^{?}$ by \autoref{def:embed-t}.

    % 6. Claim well-typedness of the embedded table. (4, 5)
    Then, $(C_p \vdash ex_t^{*}\; \<table> n\; i^n : ex_t^{*}\; (n,\tfi_t^n))^{?}$, by \refrule{Table}.

    % 7. Claim well-typedness of the embedded functions. (1, 4)
    $(C_p \vdash \embed[f]{f} : ex_f^{*}\; \tfi)^{*}$ by \reflemma{Sound Function Typing Embedding}.

    % 8. Claim well-typedness of embedded module. (4, 6, 7)
    Therefore, $\vdash \embed[module]{\<wmodule> f^{*}\;glob^{*}\;tab^{?}\;mem^{*}}$.
\end{proof}

\begin{lemma}{Sound Function Typing Embedding}

    If $C_w \vdash f : ex_f^{*}\; t_1^{*} \rightarrow t_2^{*}$, where
    $C_w = \{ \text{func } \tf^{*},\; \text{global } tg^{*},\; \text{table } n^{?},\; \text{memory } n^{?} \}$,
    $C_p = \{ \text{func } \tfi^{*},\; \text{global } tg^{*},\; \text{table } (n,\tfi_t^n)^{?}, \text{memory } n^{?} \}$,
    \\ then $C_p \vdash \embed[f]{f}^{*} : ex_f^{*}\; \tfi_f$, where
    $\tfi_f = \ti{t_1}{a_1}^{*};\epsilon;(\circ,\ti{t_1}{a_1}^{*}) \rightarrow \ti{t_2}{a_2}^{*};\epsilon;(\circ,\ti{t_2}{a_2}^{*})$,
    $\phi_1 = (\circ,\ti{t_1}{a_1}^{*})$,
    $\phi_2 = (\circ,\ti{t_2}{a_2}^{*})$.
    % These are just to make the statements not quite so long
\end{lemma}
\begin{proof}

    Proceed by cases on the definition of $f$.

    \begin{enumerate}
        \item $f = ex_f^{*}\; \<wfunc> \tf\; \<wlocal>\; t^{*}\; e^{*}$

        $C_w,\text{local } t_1^{*}\;t^{*},\text{label } (t_2^{*}),\text{return } (t_2^{*}) \vdash e^{*} : \epsilon \rightarrow t_2^{*}$ since it is a premise of WASM Func.

        $\embed[f]{f} = ex_f^{*}\; \<func> \tfi_f\; \<local>\; t^{*}\; (\embed[e]{e}^{(t_1^{*}\;t^{*})})^{*}$ by \autoref{def:embed-f}.

        Let $C_f = C_p,\text{local } t_1^{*}\;t^{*},\text{label } (\ti{t_2}{a_2}^{*};l;\phi_2),\text{return } (\ti{t_2}{a_2}^{*};l;\phi_2)$.

        \thought{l comes out of nowhere, shouldn't be a problem depending on what the instruction list lemma is}

        $C_f \vdash (\embed[e]{e}^{(t_1^{*}\;t^{*})})^{*} : \epsilon;\ti{t_1}{a_1}^{*}\;\ti{t}{a_l}^{*};\phi_1 \rightarrow \ti{t_2}{a_2}^{*};l;\phi_2$ by \reflemma{Sound Instruction List Typing Embedding}.

        \thought{where do the local type declarations get added to the constraint sets, do we need them?}

        \thought{I believe we need type declarations for all referenced index vars in the constraint set?}

        Then, $C_p \vdash ex_f^{*}\; \<func> \tfi_f\; \<local>\; t^{*}\; (\embed[e]{e}^{(t_1^{*}\;t^{*})})^{*} : ex_f^{*}\; \tfi_f$ by \refrule{Func}.

        \item $f = ex_f^{*}\; \<wfunc> \tf\; im$

        $\embed[f]{f} = ex_f^{*}\; \<func> \tfi_f\; im$ by \autoref{def:embed-f}.

        Then, $C_p \vdash ex_f^{*}\; \<func> \tfi_f\; im : ex_f^{*}\; \tfi_f$ by \refrule{Imported Func}.

    \end{enumerate}
\end{proof}

\begin{lemma}{Sound Instruction List Typing Embedding}

    If $C_w \vdash e^{*} : \epsilon \rightarrow t_2^{*}$,
    $C_w = \{ \text{func } \tf^{*}, \text{global } tg^{*}, \text{table } n_t^{?}, \text{memory } n_m^{?}, \text{local } t_l^{*}, \text{label } (t_2^{*}), \text{return } (t_2^{*}) \}$,
    $C_p = \{ \text{func } \tfi^{*}, \text{global } tg^{*}, \text{table } (n_t,\tfi_t^n)^{?}, \text{memory } n_m^{?}, \text{local } t_l^{*}, \text{label } (\ti{t_2}{a_2}^{*};l_2;\phi_2), \text{return } (\ti{t_2}{a_2}^{*};l_2;\phi_2) \}$, where
    $\tf = \epsilon \rightarrow t_2^{*}$,
    $\tfi = \epsilon;\ti{t_l}{a_l}^{*};(\circ,\ti{t_l}{a_l}^{*}) \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2$,
    $\phi_2 = \circ,\ti{t_2}{a_2}^{*}$,
    \\ then $C_p \vdash (\embed[e]{e}^{(t_l^{*})})^{*} : \epsilon;\ti{t_l}{a_l}^{*};(\circ,\ti{t_l}{a_l}^{*}) \rightarrow ti^{*};l_2;\phi_2$.

    \thought{This is one nasty lemma, but requires all the specifics because if we're not careful the prechk code adds information.}

    \thought{This is still a little over-specific, i.e. I think we could allow for non-empty preconditions, but I think this is all we need.}
\end{lemma}
\begin{proof}

    \thought{How....}

    Since no constraints are placed on the index variables $a_2^{*}$, any values of type $t_2$ will satisfy $\phi_2$.

    Since the WASM rules guarantee that the postcondition values of $e^{*}$ have type $t_2$.

    % I need to claim that the embedded instructions have the same type type.
    % Then how can I claim composition - it relies on what the type annotations for block, loop instructions are.
    % Maybe I should make a lemma about composition specifically?

    Thought maybe this lemma could mimick the typing rule and make a claim about $e^{*}\;e$? that way I can show composition with the rest and kind of recursively deconstruct any instruction list.
    this does prevent us from typing empty instruction lists, which I think might be valid wasm code as long as the instruction is $\epsilon \rightarrow \epsilon$.

    Proceed by cases on the instruction list, either $e^{*} = \epsilon$, or $e^{*} = e_1^{*}\; e_2$, then claim that $e_1^{*}$ types under WASM by inversion on WASM composition,
    then use the inversion on composition to claim that the WASM precondition of $e_2$ is the postcondition of $e_1^{*}$, then invoke an instruction based lemma that claims WASM well-typed
    implies the embedding is prechk well-typed with a type that makes it fit what we want here.

    \begin{enumerate}
        \item $e^{*} = \epsilon$

        $t_2^{*} = \epsilon$ by \todo{not sure how to justify, inversion on WASM Empty?}

        Then we can choose $l_2 = \ti{t_l}{a_l}^{*}$.

        Note that $\phi_2 = \circ$.

        $C_p \vdash \epsilon : \epsilon;\ti{t_l}{a_l}^{*};(\circ,\ti{t_l}{a_l}^{*}) \rightarrow \epsilon;l_2;(\phi_2,\ti{t_l}{a_l}^{*})$ by \refrule{Empty}.

        Therefore, $C_p \vdash \epsilon : \epsilon;\ti{t_l}{a_l}^{*};(\circ,\ti{t_l}{a_l}^{*}) \rightarrow \epsilon;l_2;\phi_2$ by \refrule{Implies}.

        Therefore, $C_p \vdash (\embed[e]{e^{*}}) : \epsilon;\ti{t_l}{a_l}^{*};(\circ,\ti{t_l}{a_l}^{*}) \rightarrow \epsilon;l_2;\phi_2$ by \refrule{Implies}.

        \item $e^{*} = e_1^{*}\; e_2^{*}$

        \thought{claim inversion on WASM typing to get a type, then invoke the instruction typing lemma to show the embedding has an equivalent type, then invoke this lemma again}

        By inversion on WASM composition, $C_w \vdash e_1^{*} : \epsilon \rightarrow t_3^{*}$ and $C_w \vdash e_2 : t_3^{*} \rightarrow t_2^{*}$.

        $C_p \vdash \embed[e]{e_2}^{(t_l^{*})} : \ti{t_3}{a_3}^{*};l_3;\phi_3 \rightarrow \ti{t_2}{a_2}^{*};l_2;\phi_2$ by \reflemma{Sound Instruction Typing Embedding}.

        \todo{Will have to specify the exact layout of $l_3$, $\phi_3$, this will have to include the local type declarations}.

        $C_p \vdash (\embed[e_1]{e_1}^{(t_l^{*})})^{*} : \epsilon;l_1;\phi_1 \rightarrow \ti{t_3}{a_3}^{*};l_3;\phi_3$ by \reflemma{Sound Instruction List Typing Embedding}.

        \todo{$l_1$, $\phi_1$ are currently not specified, will specify them earlier so I don't have to write out the exact definition every time.}

        Therefore, $C_p \vdash (\embed[e]{e^{*}}) : \epsilon;\ti{t_l}{a_l}^{*};(\circ,\ti{t_l}{a_l}^{*}) \rightarrow \epsilon;l_2;\phi_2$ by \refrule{Composition}.

    \end{enumerate}

\end{proof}

\begin{lemma}{Sound Instruction Typing Embedding}

    If $C_w \vdash e : t_1^{*} \rightarrow t_2^{*}$,
    \\ then $C_p \vdash \embed[e]{e}^{(t_l^{*})} : \ti{t_1}{a_1}^{*};\ti{t_l}{a_3}^{*};\phi_1 \rightarrow \ti{t_2}{a_2}^{*};\ti{t_l}{a_4}^{*};\phi_2$, where
    $\phi_1 = \circ,\ti{t_1}{a_1}^{*},\ti{t_l}{a_3}^{*}$,
    $\phi_2 = \circ,\ti{t_2}{a_2}^{*},\ti{t_l}{a_4}^{*}$.
\end{lemma}

