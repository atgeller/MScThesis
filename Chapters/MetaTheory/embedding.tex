\subsection{Embedding \wasm in \name}
\label{subsec:embedding}
We present a way to embed \wasm programs in \name.
The embedding function takes a \wasm program and replaces all of the type annotations with indexed function types that have no constraints on the variables.
Intuitively, this is the only part of the surface syntax of \wasm that isn't in \name, so we must figure out a way to bring it over.
While this embedding requires no additional developer effort, it provides no information to the indexed type system beyond what can be inferred from the instructions in the program.
We conjecture that a well typed \wasm program embedded in \name is also well typed, but we have not proved it.

We typeset \name instructions in a \tbsf{blue sans serif font} and \wasm instruction in a \trbf{bold red font} to set them apart.

\begin{conjecture}{Well Typed \wasm Programs Embedded in \name are Well Typed}

    If $\vdash \<wmodule> f^{*}\;glob^{*}\;tab^{?}\;mem^{?}$,
    \\then $\vdash \embed[module]{\<wmodule> f^{*}\;glob^{*}\;tab^{?}\;mem^{?}}$
\end{conjecture}

In order to support embedding of both local and imported functions we need a syntactic way of extracting the type annotation from the function.

\begin{definition}{\fbox{$annotation(f)=\tfi$}}
    \begin{mathpar}
        \begin{array}{rcl}
            annotation(ex^{*}\; \<func> \tfi\; \<local>\; t^{*}\; e^{*})
            &=& \tfi\\
            annotation(ex^{*}\; \<func> \tfi\; im)
            &=& \tfi\\
        \end{array}
    \end{mathpar}
\end{definition}

Embedding works purely over the surface syntax of the languages.
As such, we define embedding over modules: the pinnacle syntactic objects of both the \wasm and \name surface syntax hierarchies.
Embedding a module $module$ means embedding all of the functions $f^{*}$ in the module, and embedding the table $tab$ parameterized with all of the function definitions $f^{*}$.
We do not have to embed globals $glob^{*}$ or the memory $mem^{?}$ as they have the same syntax in both \wasm and \name.
We explain how to embed tables $tab$ in \autoref{def:embed-t}, and functions $f$ in \autoref{def:embed-f}.

\begin{definition}{\fbox{$\embed[module]{module}=\mathbluesf{module}$}}
    \label{def:embed-m}
    \begin{mathpar}
        \begin{array}{rcl}
            embed_{module}(\<wmodule> f^{*}\; glob^{*}\; tab^{?}\; mem^{?})
            &=& \<module>
            \begin{stackTL}
                \embed[f]{f}^{*}
                \\ glob^{*}
                \\ \embed[tab]{tab^{?}}^{annotation(f)^{*}}
                \\ mem^{?}
            \end{stackTL} \\
        \end{array}
    \end{mathpar}
\end{definition}

Tables in \name must also provide the indexed function types of all the functions they contain, so to embed them we must include those types.
We do this by parameterizing the embedding of the table $tab$ with all of the function types $\tfi^{*}$.
Then, we retrieve the indexed function type $ti_1;l_1;\phi_1 \rightarrow ti_2;l_2;\phi_2$ of the function pointed to by the function index $i$ in $\tfi^{*}$ for every function index $i$ in the table.
We cannot embed imported tables because we have no way of accessing the types of the functions included in the table.

\begin{definition}{\fbox{$\embed[tab]{tab}^{\tfi^{*}}=\mathbluesf{tab}$}}
    \label{def:embed-t}
    \begin{mathpar}
        \begin{array}{rcl}
            embed_{tab}(ex^{*}\; \<wtable> n\; i^{n})
            &=& ex^{*}\; \<table> n\; (ti_1;\epsilon;\phi_1 \rightarrow ti_2;\epsilon;\phi_2)^{n} \\
            && \text{where } \forall i. \tfi^{*}(i) = ti_1;\epsilon;\phi_1 \rightarrow ti_2;\epsilon;\phi_2
        \end{array}
    \end{mathpar}
\end{definition}

The embedding of functions, \autoref{def:embed-f}, both must construct an indexed function type for itself and embed its body.
Function bodies have their local variables defined by the function that they are enclosed in.
Thus, when the function body is embedded we pass the local types ($t_1^{*}\;t^{*}$) so the body knows how to constrain local variables.
We construct an indexed function type that has the precondition of the expected values on the stack turned into indexed types using fresh index variables and the types $t_1^{*}$ from the \wasm type, and do the same with the postcondition and $t_2^{*}$.

\begin{definition}{\fbox{$\embed[f]{f}=\mathbluesf{f}$}}
    \label{def:embed-f}
    \begin{mathpar}
        \begin{array}{rcl}
            embed_f(ex^{*}\; \<wfunc>
            \begin{stackTL}
                (t_1^{*} \rightarrow t_2^{*})
                \\ \<wlocal>\; t^{*}\; e^{*})
            \end{stackTL}
            &=& ex^{*}\; \<func>\;
                \begin{stackTL}
                    (\ti{t_1}{a_1}^{*};\epsilon;(\circ,\ti{t_1}{a_1}^{*})
                    \\ \rightarrow
                    \ti{t_2}{a_2}^{*};\epsilon;(\circ,\ti{t_2}{a_2}^{*}))
                    \\ \<local>\; t^{*}\; (\embed[e]{e}^{(t_1^{*}\;t^{*})})^{*}
                \end{stackTL}\\
            embed_f(ex^{*}\; \<wfunc> (t_1^{*} \rightarrow t_2^{*})\; im)
            &=& ex^{*}\; \<func>\;
                \begin{stackTL}
                    (\ti{t_1}{a_1}^{*};\epsilon;(\circ,\ti{t_1}{a_1}^{*})
                    \\ \rightarrow
                    \ti{t_2}{a_2}^{*};\epsilon;(\circ,\ti{t_2}{a_2}^{*}))
                    \\ im
                \end{stackTL}\\
        \end{array}
    \end{mathpar}
\end{definition}

Embedding instructions replaces all function types used within the \wasm syntax with \name indexed function types, and adds the function types for all of the functions in a table to the table's type declaration.
This occurs within blocks and indirect function calls, as shown in \autoref{def:embed-e}.
The indexed types simply have fresh index variables that are different in the precondition and postcondition, and the primitive types for the stack are known from the \wasm type $t_1^{*} \rightarrow t_2^{*}$.
To know what the local variables are, we parameterize the embedding over the types of local variables ($t^{*}$).

\begin{definition}{\fbox{$\embed[e]{e}^{t^{*}}=\mathbluesf{e}$}}
    \label{def:embed-e}
    \begin{mathpar}
        %% SPACE HACKS
        \arraycolsep=2pt
        \begin{array}{rcl}
            embed_{e^{*}}({\begin{stackTL}
                \<wblock>
                {\begin{stackTL}
                    (t_1^{*} \rightarrow t_2^{*})\;
                    \\e^{*}
                \end{stackTL}}\\
            \<wend>)^{t^{*}}
            \end{stackTL}}
            &=& {\begin{stackTL}
                    \<block>
                    \\ \quad (\ti{t_1}{a_1}^{*};\ti{t}{a_3}^{*};(\circ,\ti{t_1}{a_1}^{*},\ti{t}{a_3}^{*})
                    \\ \quad\; \rightarrow \ti{t_2}{a_2}^{*};\ti{t}{a_4}^{*};(\circ,\ti{t_2}{a_2}^{*},\ti{t}{a_4}^{*}))
                    \\ \quad \embed[e^{*}]{e^{*}}^{t^{*}}
            \end{stackTL}} \\
            && \<nsend>\\

            embed_{e^{*}}({\begin{stackTL}
                \<wloop>
                {\begin{stackTL}
                    (t_1^{*}\rightarrow t_2^{*})\;
                    \\e^{*}
                \end{stackTL}}\\
            \<wend>)^{t^{*}}
            \end{stackTL}}
            &=& {\begin{stackTL}
                    \<loop>
                    \\ \quad (\ti{t_1}{a_1}^{*};\ti{t}{a_3}^{*};(\circ,\ti{t_1}{a_1}^{*},\ti{t}{a_3}^{*})
                    \\ \quad\; \rightarrow \ti{t_2}{a_2}^{*};\ti{t}{a_4}^{*};(\circ,\ti{t_2}{a_2}^{*},\ti{t}{a_4}^{*}))
                    \\ \quad \embed[e^{*}]{e^{*}}^{t^{*}}
            \end{stackTL}} \\
            && \<nsend>\\

            embed_{e^{*}}({\begin{stackTL}
                \<wif>
                {\begin{stackTL}
                    (t_1^{*}\rightarrow t_2^{*})\;
                    \\e^{*}
                \end{stackTL}}\\
            \<wend>)^{t^{*}}
            \end{stackTL}}
            &=& {\begin{stackTL}
                    \<if>
                    \\ \quad (\ti{t_1}{a_1}^{*};\ti{t}{a_3}^{*};(\circ,\ti{t_1}{a_1}^{*},\ti{t}{a_3}^{*})
                    \\ \quad\; \rightarrow \ti{t_2}{a_2}^{*};\ti{t}{a_4}^{*};(\circ,\ti{t_2}{a_2}^{*},\ti{t}{a_4}^{*}))
                    \\ \quad \embed[e]{e_1^{*}}^{t^{*}}\; \embed[e]{e_2^{*}}^{t^{*}}
                \end{stackTL}} \\
            && \<nsend>\\

            embed_{e^{*}}(
                {\begin{stackTL}
                    \<wcallindirect>
                    \\\quad (t_1^{*}\rightarrow t_2^{*}))^{t^{*}}
                \end{stackTL}}
            &=& {\begin{stackTL}
                \<callindirect>
                \\ \quad (\ti{t_1}{a_1}^{*};\ti{t}{a_3}^{*};(\circ,\ti{t_1}{a_1}^{*},\ti{t}{a_3}^{*})
                \\ \quad\; \rightarrow \ti{t_2}{a_2}^{*};\ti{t}{a_4}^{*};(\circ,\ti{t_2}{a_2}^{*},\ti{t}{a_4}^{*}))
            \end{stackTL}} \\

            \embed[e^{*}]{e}^{t^{*}} &=& e \text{, otherwise} \\
            \embed[e^{*}]{e^{*}}^{t^{*}} &=& (\embed[e^{*}]{e}^{t^{*}})^{*} \\
        \end{array}
    \end{mathpar}
\end{definition}

These are not the only differences in the surface syntax between \wasm and \name: we also introduced four new instructions (the \prechk-tagged instructions).
The definition of embedding we have introduced has been entirely syntactic, but that will not work for replacing non-\prechk-tagged instructions with \prechk-tagged versions during embedding since we must be able to ensure that stronger guarantees are met.
Instead, one could, for example, check at every $\<div>$, $\<callindirect>$, $\<load>$, and $\<store>$ whether the \prechk-tagged version of the instruction is welltyped, and only if it is well typed replace the instruction with the \prechk-tagged version.
However, a more sophisticated static analysis could be able to provide more precise type annotations and therefore potentially allow even check eliminations.

Want to prove that the embedding produces well-typed \name, embedding works on a module level, so the proof should be done on a module level.


\begin{theorem}{Sound Module Typing Embedding}
    \label{thm:moduleembedding}

    If $\vdash \<wmodule> f^{*}\;glob^{*}\;tab^{?}\;mem^{?}$ and
    $tab = (ex_t^{*}\; \<wtable> n\; i^n)$,
    \\ then $\vdash \embed[module]{\<wmodule> f^{*}\;glob^{*}\;tab^{?}\;mem^{?}}$
\end{theorem}
\begin{proof}

    Note that the globals $glob^{*}$ and memory $mem^{?}$ are not affected by embedding, and have the same module typing rules in \wasm as in \name.
    Thus, we only need to reason about the functions $f^{*}$ and table $tab^{?}$.

    % 1. Instantiate premises of WASM module.
    $(C_w \vdash f : ex_f^{*}\; \tf)^{*}$, where
    $C_w = \{ \text{func } \tf^{*},\; \text{global } tg^{*},\; \text{table } n^{?},\; \text{memory } n^{?} \}$
    since they are premises of WASM module.

    % 2. Instantiate the structure of the function embeddings. This gets us the type annotations of the functions.
    $(annotation(\embed[f]{f}) = \tfi)^{*}$.

    % 3. Construct the table types from the function annotations and i. (2)
    Let $\tfi_t = (\forall i. \tfi^n(i))^{?}$.

    % 4. Construct the context for the embeddings. (2, 3)
    Let $C_p = \{ \text{func } \tfi^{*}, \text{global } tg^{*}, \text{table } (n,\tfi_t^n)^{?}, \text{memory } n^{?} \}$.

    % 5. Instantiate the table embedding, using the definition of tfi_t above. (3)
    $\embed[tab]{tab^{?}}^{\tfi^{*}} = (ex_t^{*}\; \<table> n\; \tfi_t^n)^{?}$ by \autoref{def:embed-t}.

    % 6. Claim well-typedness of the embedded table. (4, 5)
    Then, $(C_p \vdash ex_t^{*}\; \<table> n\; i^n : ex_t^{*}\; (n,\tfi_t^n))^{?}$, by \refrule{Table}.

    % 7. Claim well-typedness of the embedded functions. (1, 4)
    $(C_p \vdash \embed[f]{f} : ex_f^{*}\; \tfi)^{*}$ by \reflemma{Sound Function Typing Embedding}.

    % 8. Claim well-typedness of embedded module. (4, 6, 7)
    Therefore, $\vdash \embed[module]{\<wmodule> f^{*}\;glob^{*}\;tab^{?}\;mem^{*}}$.
\end{proof}

\begin{lemma}{Sound Function Typing Embedding}

    If $C_w \vdash f : ex_f^{*}\; t_1^{*} \rightarrow t_2^{*}$,
    $C_w = \{ \text{func } \tf^{*},\; \text{global } tg^{*},\; \text{table } n^{?}, \text{memory } n^{?} \}$,
    $C_p = \{ \text{func } \tfi^{*},\; \text{global } tg^{*},\; \text{table } (n,\tfi_t^n)^{?}, \text{memory } n^{?} \}$,
    % make sure the function definitions match
    $(\erase[\tfi]{\tfi} = \tf)^{*}$,
    \\ then $C_p \vdash \embed[f]{f}^{*} : ex_f^{*}\; \tfi_f$, where
    % These are just to make the statements not quite so long
    $\tfi_f = \ti{t_1}{a_1}^{*};\epsilon;\phi_1 \rightarrow \ti{t_2}{a_2}^{*};\epsilon;\phi_2$,
    $\phi_1 = \circ,\ti{t_1}{a_1}^{*}$,
    $\phi_2 = \circ,\ti{t_2}{a_2}^{*}$.
\end{lemma}
\begin{proof}

    Proceed by cases on the typing derivation of $C_w \vdash f : ex_f^{*}\; t_1^{*} \rightarrow t_2^{*}$.

    \begin{enumerate}
        \item $f = ex_f^{*}\; \<wfunc> t_1^{*} \rightarrow t_2^{*}\; \<wlocal>\; t^{*}\; e^{*}$
        \\ $\land$ $C_w \vdash ex_f^{*}\; \<wfunc> t_1^{*} \rightarrow t_2^{*}\; \<wlocal>\; t^{*}\; e^{*} : ex_f^{*}\; t_1^{*} \rightarrow t_2^{*}$

        $C_w,\text{local } t_1^{*}\;t^{*},\text{label } (t_2^{*}),\text{return } (t_2^{*}) \vdash e^{*} : \epsilon \rightarrow t_2^{*}$ since it is a premise of WASM Func.

        $\embed[f]{f} = ex_f^{*}\; \<func> \tfi_f\; \<local>\; t^{*}\; (\embed[e]{e}^{(t_1^{*}\;t^{*})})^{*}$ by \autoref{def:embed-f}.

        Let $C_f = C_p,\text{local } t_1^{*}\;t^{*},\text{label } (\ti{t_2}{a_2}^{*};l;\phi_2),\text{return } (\ti{t_2}{a_2}^{*};l;\phi_2)$.

        \thought{$l$ comes out of nowhere, should it be more specified?}

        Let $l_1 = \ti{t_1}{a_1}^{*}\;\ti{t}{a_l}^{*}$.

        $C_f \vdash (\embed[e]{e}^{(t_1^{*}\;t^{*})})^{*} : \epsilon;l_1;\phi_1 \rightarrow \ti{t_2}{a_2}^{*};l;\phi_2$ by \reflemma{Sound Instruction Typing Embedding}.

        \todo{This doesn't really work, since $\phi_1$ and $\phi_2$ don't reference the locals, so the $\phi$s and $C_f$ doesn't match the premises of the lemma}.

        \thought{umm, $a_2$, $l$, and $\phi_2$ are part of $C_f$, but are also getting chosen in the Sound Instruction Typing Embedding lemma...}

        \thought{we could have the postcondition of the lemma not be the same as what's put in the context, then have a kind of cohesion lemma/proof that things match up?}

        \thought{somehow use the fact that any values will satisfy the postcondition?}

        \thought{we know that the number and types of the values on the stack and locals match from the wasm typing.}

        Then, $C_p \vdash ex_f^{*}\; \<func> \tfi_f\; \<local>\; t^{*}\; (\embed[e]{e}^{(t_1^{*}\;t^{*})})^{*} : ex_f^{*}\; \tfi_f$ by \refrule{Func}.

        \item $f = ex_f^{*}\; \<wfunc> t_1^{*} \rightarrow t_2^{*}\; im$
        \\ $\land$ $C_w \vdash ex_f^{*}\; \<wfunc> t_1^{*} \rightarrow t_2^{*}\; im : ex_f^{*}\; t_1^{*} \rightarrow t_2^{*}$

        $\embed[f]{f} = ex_f^{*}\; \<func> \tfi_f\; im$ by \autoref{def:embed-f}.

        Then, $C_p \vdash ex_f^{*}\; \<func> \tfi_f\; im : ex_f^{*}\; \tfi_f$ by \refrule{Imported Func}.

    \end{enumerate}
\end{proof}

\begin{lemma}{Sound Instruction Typing Embedding}

    If $C_w \vdash e^{*} : t_1^{*} \rightarrow t_2^{*}$,
    $C_w = \{
        \text{func } \tf^{*},
        \text{global } tg^{*},
        \text{table } n_t^{?},
        \text{memory } n_m^{?},
        \text{local } t_l^{*},
        \text{label } (t_b^{*})^{*},
        \text{return } (t_r^{*})^{?}
    \}$,
    $C_p = \{
        \text{func } \tfi^{*},
        \text{global } tg^{*},
        \text{table } (n_t,\tfi_t^n)^{?},
        \text{memory } n_m^{?}, \text{local } t_l^{*},
        \text{local } t_l^{*},
        \text{label } (\ti{t_b}{a_b};l_b;(\circ,l_b,\ti{t_b}{a_b}))^{*},
        \text{return } (\ti{t_r}{a_r};l_r;(\circ,\ti{t_r}{a_r}))^{?}
    \}$,
    % note that the label types include the locals types, but that the return type doesn't - this isn't quite right, need to do some changes to function typing
    % make sure the function definitions match
    $(\erase[\tfi]{\tfi} = \tf)^{*}$,
    % claiming that for all valid precondition types of this form...
    $ti_1^{*} = \ti{t_1}{a_1}^{*}$,
    $l_1 = \ti{t_l}{a_{l1}}^{*}$,
    $\phi_1 = \circ,l_1,ti_1^{*}$.
    \\ then $C_p \vdash (\embed[e]{e}^{(t_l^{*})})^{*} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$, where
    % there exists a valid postcondition type of this form.
    $ti_2^{*} = \ti{t_2}{a_2}^{*}$,
    $l_2 = \ti{t_l}{a_{l2}}^{*}$,
    $\phi_2 = \circ,l_2,ti_2^{*}$.
\end{lemma}
\begin{proof}

    Proceed by induction on the depth of the typing derivation of $C_w \vdash e^{*} : t_1^{*} \rightarrow t_2^{*}$.

    \begin{enumerate}
        % WASM Const
        \item $e^{*} = t.\<const> c$
        \\ $\land$ $t_1^{*} = \epsilon$
        \\ $\land$ $t_2^{*} = t$
        \\ $\land$ $C_w \vdash t.\<const> c : \epsilon \rightarrow t$

        Want to show $C_p \vdash t.\<const> c : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        Choose $l_2 = l_1$.

        $C_p \vdash t.\<const> c : \epsilon;l_1;\phi_1 \rightarrow \ti{t}{a};l_2;(\phi_1,\ti{t}{a},(=\;a\;\ti{t}{c}))$ by \refrule{Const}.

        $\phi_1,\ti{t}{a},(=\;a\;\ti{t}{c}) \implies \phi_1,\ti{t}{a}$ trivially.

        $C_p \vdash t.\<const> c : \epsilon;l_1;\phi_1 \rightarrow \ti{t}{a};l_2;(\phi_1,\ti{t}{a})$ by \refrule{Implies}.

        Note that since $t_1^{*} = \epsilon$, $ti_1^{*} = \epsilon$.

        Choose $ti_2^{*} = \ti{t}{a}$, $\phi_2 = \phi_1,\ti{t}{a}$, note that this choice of $\phi_2$ is consistent with our choice of $l_2$.

        Therefore, $C_p \vdash t.\<const> c : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        % WASM binop
        \item $e^{*} = t.\<binop>$
        \\ $\land$ $t_1^{*} = t\;t$
        \\ $\land$ $t_2^{*} = t$
        \\ $\land$ $C_w \vdash t.\<binop> : t\;t \rightarrow t$

        Want to show $C_p \vdash t.\<binop> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        Choose $l_2 = l_1$.

        Note that since $t_1^{*} = t\;t$, $ti_1^{*} = \ti{t}{a_3}\;\ti{t}{a_4}$.

        $C_p \vdash t.\<binop> : \ti{t}{a_3}\;\ti{t}{a_4};l_1;\phi_1 \rightarrow \ti{t}{a_5};l_2;(\phi_1,\ti{t}{a_5},(=\;a_5\;(\|\<binop>\|\;a_3\;a_4)))$ by \refrule{Binop}.

        $\phi_1,\ti{t}{a_5},(=\;a_5\;(\|\<binop>\|\;a_3\;a_4)) \implies \phi_1,\ti{t}{a_5}$ trivially.

        Choose $\phi_2 = \circ,l_2,\ti{t}{a_5}$.

        $\phi_1,\ti{t}{a_5} \implies \phi_2$ trivially.

        $C_p \vdash t.\<binop> : \ti{t}{a_3}\;\ti{t}{a_4};l_1;\phi_1 \rightarrow \ti{t}{a_5};l_2;\phi_2$ by \refrule{Implies}.

        Choose $ti_2^{*} = \ti{t}{a_5}$.

        Therefore, $C_p \vdash t.\<binop> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        % WASM testop
        \item $e^{*} = t.\<testop>$
        \\ $\land$ $t_1^{*} = t$
        \\ $\land$ $t_2^{*} = \<ithreetwo>$
        \\ $\land$ $C_w \vdash t.\<testop> : t \rightarrow \<ithreetwo>$

        Want to show $C_p \vdash t.\<testop> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        Choose $l_2 = l_1$.

        Note that since $t_1^{*} = t$, $ti_1^{*} = \ti{t}{a_3}$.

        $C_p \vdash t.\<testop> : \ti{t}{a_3};l_1;\phi_1 \rightarrow \ti{\<ithreetwo>}{a_4};l_2;(\phi_1,\ti{\<ithreetwo>}{a_4},(=\;a_4\;(\|\<testop>\|\;a_3)))$ by \refrule{Testop}.

        $\phi_1,\ti{\<ithreetwo>}{a_4},(=\;a_4\;(\|\<testop>\|\;a_3)) \implies \phi_1,\ti{\<ithreetwo>}{a_4}$ trivially.

        Choose $\phi_2 = \circ,l_2,\ti{\<ithreetwo>}{a_4}$.

        $\phi_1,\ti{\<ithreetwo>}{a_4} \implies \phi_2$ trivially.

        $C_p \vdash t.\<testop> : \ti{t}{a_3};l_1;\phi_1 \rightarrow \ti{\<ithreetwo>}{a_4};l_2;\phi_2$ by \refrule{Implies}.

        Choose $ti_2^{*} = \ti{\<ithreetwo>}{a_4}$.

        Therefore, $C_p \vdash t.\<testop> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        % WASM relop
        \item $e^{*} = t.\<relop>$
        \\ $\land$ $t_1^{*} = t\;t$
        \\ $\land$ $t_2^{*} = \<ithreetwo>$
        \\ $\land$ $C_w \vdash t.\<relop> : t\;t \rightarrow \<ithreetwo>$

        Want to show $C_p \vdash t.\<relop> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        Choose $l_2 = l_1$.

        Note that since $t_1^{*} = t\;t$, $ti_1^{*} = \ti{t}{a_3}\;\ti{t}{a_4}$.

        $C_p \vdash t.\<relop> : \ti{t}{a_3}\;\ti{t}{a_4};l_1;\phi_1 \rightarrow \ti{\<ithreetwo>}{a_5};l_2;(\phi_1,\ti{\<ithreetwo>}{a_5},(=\;a_5\;(\|\<relop>\|\;a_3\;a_4)))$ by \refrule{Relop}.

        $\phi_1,\ti{\<ithreetwo>}{a_5},(=\;a_5\;(\|\<relop>\|\;a_3\;a_4)) \implies \phi_1,\ti{\<ithreetwo>}{a_5}$ trivially.

        Choose $\phi_2 = \circ,l_2,\ti{\<ithreetwo>}{a_5}$.

        $\phi_1,\ti{\<ithreetwo>}{a_5} \implies \phi_2$ trivially.

        $C_p \vdash t.\<relop> : \ti{t}{a_3}\;\ti{t}{a_4};l_1;\phi_1 \rightarrow \ti{\<ithreetwo>}{a_5};l_2;\phi_2$ by \refrule{Implies}.

        Choose $ti_2^{*} = \ti{\<ithreetwo>}{a_5}$.

        Therefore, $C_p \vdash t.\<relop> : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        % WASM Empty
        \item $e^{*} = \epsilon$
        \\ $\land$ $t_1^{*} = t_2^{*} = \epsilon$
        \\ $\land$ $C_w \vdash \epsilon : \epsilon \rightarrow \epsilon$

        Want to show $C_p \vdash \epsilon : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        $C_p \vdash \epsilon : \epsilon;l_1;\phi_1 \rightarrow \epsilon;l_1;\phi_1$ by \refrule{Empty}.

        Note that since $t_1^{*} = \epsilon$, $ti_1^{*} = \epsilon$.

        Choose $ti_2^{*} = \epsilon$, $l_2 = l_1$, $\phi_2 = \phi_1$.

        Therefore, $C_p \vdash \epsilon : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        % WASM Composition
        \item $e^{*} = e_1^{*}\; e_2$
        \\ $\land$ $C_w \vdash e_1^{*} : t_1^{*} \rightarrow t_3^{*}$
        \\ $\land$ $C_w \vdash e_2 : t_3^{*} \rightarrow t_2^{*}$

        Want to show $C_p \vdash (\embed[e]{e_1}^{(t_l^{*})})^{*}\; \embed[e]{e_2}^{(t_l^{*})} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        Note that $ti_3^{*}, l_3, \phi_3$ are getting defined in the first invocation of the inductive hypothesis.

        $C_p \vdash (\embed[e]{e_1}^{(t_l^{*})})^{*} : ti_1^{*};l_1;\phi_1 \rightarrow ti_3^{*};l_3;\phi_3$ by the inductive hypothesis.

        $C_p \vdash \embed[e]{e_2}^{(t_l^{*})} : ti_3^{*};l_3;\phi_3 \rightarrow ti_2^{*};l_2;\phi_2$ by the inductive hypothesis.

        \thought{
            This relies on the fact that we're making existential claims on the postcondition from forall claims on the precondition.
            The first claim of the inductive hypothesis chooses values for $ti_3^{*}, l_3, \phi_3$, that are then validly used in the second one because they're under a forall.
        }

        Therefore, $C_p \vdash (\embed[e]{e_1}^{(t_l^{*})})^{*}\; \embed[e]{e_2}^{(t_l^{*})} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$ by \refrule{Composition}.

        % WASM Stack Polymorphism
        \item $t_1^{*} = t^{*}\; t_3^{*}$
        \\ $\land$ $t_2^{*} = t^{*}\; t_4^{*}$
        \\ $\land$ $C_w \vdash e^{*} : t_3^{*} \rightarrow t_4^{*}$

        Want to show $C_p \vdash (\embed[e]{e}^{(t_l^{*})})^{*} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

        Let $ti_1^{*} = \ti{t}{a}^{*}\; \ti{t_3}{a_3}^{*}$, $\phi_3 = \circ,l_1,\ti{t_3}{a_3}^{*}$.

        $C_p \vdash (\embed[e]{e}^{(t_l^{*})})^{*} : \ti{t_3}{a_3}^{*};l_1;\phi_3 \rightarrow \ti{t_4}{a_4}^{*};l_2;\phi_4$ by the inductive hypothesis.

        Because $a$ are fresh, $\phi_3,\ti{t}{a}^{*} \implies \phi_3$.

        Note that $\phi_1 = \phi_3,\ti{t}{a}^{*}$.

        \thought{Are they really fresh? If they are, why?}

        $\phi_4 \implies \phi_4,\ti{t}{a}^{*}$ trivially.

        $C_p \vdash (\embed[e]{e}^{(t_l^{*})})^{*} : \ti{t_3}{a_3}^{*};l_1;\phi_1 \rightarrow \ti{t_4}{a_4}^{*};l_2;\phi_4,\ti{t}{a}^{*}$ by \refrule{Implies}.

        $C_p \vdash (\embed[e]{e}^{(t_l^{*})})^{*} : \ti{t}{a}^{*}\; \ti{t_3}{a_3}^{*};l_1;\phi_1 \rightarrow \ti{t}{a}^{*}\; \ti{t_4}{a_4}^{*};l_2;\phi_4,\ti{t}{a}^{*}$ by \refrule{Stack-Poly}.

        Choose $ti_2^{*} = \ti{t}{a}^{*}\; \ti{t_4}{a_4}^{*}$, $\phi_2 = \phi_4,\ti{t}{a}^{*}$.

        Therefore, $C_p \vdash (\embed[e]{e}^{(t_l^{*})})^{*} : ti_1^{*};l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2$.

    \end{enumerate}
\end{proof}

