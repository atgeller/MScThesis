\chapter{Background}
\section{\wasm}
\label{sec:wasm}
Here we present an overview of \wasm so reader's have some familiarity with it for when we present \name.
We do not cover the entirety of the \wasm language as presented in the 2017 paper, but rather selected important points about the syntax, semantics, and type system.

\subsection{\wasm Syntax}
\wasm is a stack-based assembly language.
The primitive \wasm types and values include 32 and 64-bit floats and integers.
There are many instructions:
\begin{itemize}
    \item Constants
    \item Binary and unary operations for arithmetic and comparisons. There are different ones for integers and floats.
    \item Unreachable: an instruction that triggers a ``trap'', a \wasm run-time error (think: assert false)
    \item No-op
    \item An instruction to discard the value on top of the stack
    \item A ternary operator to choose between two values on the stack based on a third value
    \item Several control flow blocks that introduce labels for branching
    \item Several branching operators, including unconditional and conditional branches
    \item Function calls and return
    \item Indirect function calls
    \item Get/set instructions for local and global variables
    \item Memory operations, including load, store, getting the current memory size, and attempting to grow the size of memory
\end{itemize}

The \wasm syntax uses the Kleene star within its BNF to refer to possibly empty sequences.
For example, instructions, $e$, are usually grouped into sequences $e^{*}$, which are possibly empty $\epsilon$.
$e_1$ and $e_2$ refer to different instructions (although the actual instruction they represent may be the same).
Similarly, $e_1^{*}$ and $e_2^{*}$ refer to different sequences of instructions (again, the sequences may be the same).
There is no requirement that a sequence of non-terminals, $e_1^{*}$, be made up of entirely the same pattern, unless it is explicitly written out as in $(t.const c)^{*}$.
For example, $e_1^{*}$ matches $(t.\<const> c_1)\; (t.\<const> c_2)\; (t.binop)$.
Further, we may separate out subsequences: from $(t.const c)^{*}$ we may separate out $t^{*}$ and $c^{*}$ to refer to the sequences of types and constant values respectively.

\wasm has modules that include linear memory, function tables, global variables, and functions.
Linear memory is simply a very large continuous chunk of memory.
Memory load and store operations require run-time bounds checks to ensure that they operate within the chunk of memory.
Function tables store references to functions that can be called using indirect function calls, they are used to more safely represent function pointers.
Indirect function calls must supply a function type that gets checked against the table function that ends up being called at run-time.
Global variables may be mutable, and are initialized via a sequence of instructions.
Functions include a list of local variable declarations to use within the body (a sequence of instructions).
Additionally, function arguments are accessible as local variables within the body of functions.

\subsection{\wasm Semantics}
\label{subsec:wasmsemantics}
\wasm uses a mixed reduction and small-step operational semantics.
The ``stack'' is actually just the sequence of values preceding the first reducible instruction.
Instructions are reduced in place by decomposing the entire program using reduction contexts.
Reduction contexts are based on label blocks, administrative instructions used to handle control flow.
Branching from inside a label block essentially peels back the specified number of label blocks, and continues executing with the stored instructions (used only by loops which store the loop code) of the containing label block.
For example, $\<label> \{\} \<label> \{\} \<label> \{\} \<br> 1 \<end> \<end> \<end>$ will reduce to $\<label> \{\} \<end>$, while $\<label> \{ \<loop> ... \<end> \} \<br> 1 \<end>$ reduces to $\<loop> ... \<end>$.

\subsection{The \wasm Type System}
\wasm is a stack-based language, so the type of an instruction in \wasm consists of a precondition and postcondition on the shape of the stack.
This can be viewed as though instructions \emph{consume} certain values from the stack and then \emph{produce} values to be pushed on the stack.
For example, a binary operation of some type $t$ consumes two values of the given type $t$ on the stack and produces a value of type $t$:

\[
    \inferrule{ }{C \vdash t.binop : t\; t \rightarrow t}
\]

The above example shows what a typical \wasm typing rule looks like.
$C$ is the module type context, which keeps track of various module-level types: functions, globals, the table, memory, locals, the label stack (\ie the expected types for branching instructions), and the return stack (\ie the expected type of the return instruction).
The type associated with the instruction $t.binop$ is a \wasm function type, which is just the precondition (on the left of the $\rightarrow$) and postcondition (on the right of the $\rightarrow$) on the stack.

\paragraph{Stack Polymorphism.}
To compose together the types of many instructions, it is necessary to carry around extra type information about the rest of the stack while type-checking instructions.
\emph{Stack polymorphism} allows extending the precondition and postcondition with the same data to thread unmodified parts of the stack through a list of instructions.
Intuitively, this allows you to ``forget'' the rest of the stack and focus only on the part being manipulated by the instruction being checked, after which point the ``forgotten'' part can be re-added.

\todo{Run through an example using concrete values}
For example, if the stack has the shape $\<isixfour>\; \<ithreetwo>\; \<ithreetwo>$, then stack polymorphism allows us to ignore $\<isixfour>$ and typecheck $\<ithreetwo>.binop$ with $\<ithreetwo>\;\<ithreetwo>$.
Then the stack would look like $\<ithreetwo>$, at which point we add $\<isixfour>$ back to the postcondtion to get $\<isixfour>\; \<ithreetwo>$ after executing $\<ithreetwo>.binop$.

\todo{Anything else to add here?}
