\chapter{Background}
\section{\wasm}
\label{sec:wasm}
Here we present an overview of \wasm so reader's have some familiarity with it for when we present \name.
We do not cover the entirety of the \wasm language as presented in the 2017 paper, but rather selected important points about the syntax, semantics, and type system.

\subsection{\wasm Syntax}
\autoref{fig:wasmsyntaxtypes} shows the types of \wasm.
Primitive \wasm types and values, represented as $t$, include 32 and 64-bit floats and integers.
Packed types, $tp$, include 8, 16, and 32 bit integers, they are used in memory operations.
Function types, $tf$, map from one sequence of types to another, although they aren't really function types in the traditional sense, as explained in \autoref{subsec:wasmtyping}.

\begin{figure}
\begin{math}
\begin{array}{rcl}
    t & ::= & \<ithreetwo> \mid \<isixfour> \mid \<fthreetwo> \mid \<fsixfour> \\
    tp & ::= & \<ieight> \mid \<isixteen> \mid \<ithreetwo> \\
    tf & ::= & t^{*} \rightarrow t^{*} \\
    tg & ::= & \text{mut}^{?}\; t
\end{array}
\end{math}
\caption{\wasm Types}
\label{fig:wasmsyntaxtypes}
\end{figure}

The \wasm syntax uses the Kleene star within its BNF to refer to possibly empty sequences.
For example, instructions, represented by the metavariable $e$, are usually grouped into sequences $e^{*}$, which are possibly empty $\epsilon$.
$e_1$ and $e_2$ refer to different instructions (although the actual instruction they represent may be the same).
Similarly, $e_1^{*}$ and $e_2^{*}$ refer to different sequences of instructions (again, the sequences may be the same).
There is no requirement that a sequence of non-terminals, $e_1^{*}$, be made up of entirely the same pattern, unless it is explicitly written out as in $(t.const c)^{*}$.
For example, $e_1^{*}$ matches $(t.\<const> c_1)\; (t.\<const> c_2)\; (t.binop)$.
Further, we may separate out subsequences: from $(t.\<const> c)^{*}$ we may separate out $t^{*}$ and $c^{*}$ to refer to the sequences of types and constant values respectively.

We can use different annotations in place of the Kleene star to add additional information.
The Kleene star may be replaced with an exact value $n$ when we know that the sequence has length $n$ (\eg a sequence of 3 values could be phrased as $v^{3}$).
We can also use a question mark to represent either an empty sequence ($\epsilon$), or a sequence with exactly one item (\eg, $v^{?}=v' \lor v^{?}=\epsilon$).

With this notation in mind, we can now look over the \wasm instructions in \autoref{fig:wasminstructions}.
As a convention, syntax written in a \tbbf{blue, bold font} denotes a keyword, while text written in $italics$ represents a metavariable.
Throughout the \wasm syntax there are many metavariables used to represent natural numbers: $n$ and $m$ are usually used for the table and memory sizes, $i$ and $j$ are often used as indexes (\eg to reference a local variable), $o$ and $align$ are used within memory operations (we replace $a$ with $align$ for clarity and since we use $a$ elsewhere), and lastly $c$ is used as a constant variable (which could also be a float).
Confusingly enough, $iN$ is used to annotate operations that support integers, and $fN$ is used to annotate operations that support floats.

Some instructions, such as $\<loop> tf\; e^{*} \<end>$ include a sequence of instructions $e^{*}$.
We refer to such instructions as block instructions, since they define control flow blocks for the instructions inside (not to be confused with the $\<block>$ insturction, which is a block instruction).
Similarly, we refer to $e^{*}$ as the body.

\begin{figure}
    \begin{math}
    \begin{array}{rcl}
        unop_{iN} & ::= & \<clz> \mid \<ctz> \mid \<popcnt> \\
        testop_{iN} & ::= & \<eqz> \\
        binop_{iN} & ::= & \<add> \mid \<sub> \mid \<shl> \mid \<or> \mid ... \\
        relop_{iN} & ::= & \<eq> \mid \<ne> \mid \<gt> \mid \<ge> \mid ... \\
        cvtop & ::= & \<convert> \mid \<reinterpret> \\
    \end{array}
    \end{math}

    \begin{math}
    \begin{array}{rcl}
        e & ::= & \<unreachable> \mid \<nop> \mid \<drop> \mid \<select> \mid \\
        && \<block> tf\; e^{*} \<end> \mid \<loop> tf\; e^{*} \<end> \mid \<if> tf\; e_1^{*} \<else> e_2^{*} \<end> \mid \\
        && \<br> i \mid \<brif> i \mid \<brtable> i^{+} \mid \<return> \mid \<call> i \mid \<callindirect> tf \mid \\
        && \<getlocal> i \mid \<setlocal> i \mid \<teelocal> i \mid \<getglobal> i \mid \\
        && \<setglobal> i \mid t.\<load> (tp\_sx)^{?}\; align\; o \mid t.\<store> tp^{?}\; align\; o \mid \\
        && \<currentmemory> \mid \<growmemory> \mid t.\<const> c \mid \\
        && t.unop_t \mid t.binop_t \mid t.testop_t \mid t.relop_t \mid t.cvtop t\_sx^{?} \\
    \end{array}
    \end{math}
    \caption{\wasm Instructions}
    \label{fig:wasminstructions}
\end{figure}

\wasm has modules that include functions ($f$), global variables ($glob$), an optional function table ($tab$), and an optional linear memory chunk ($mem$), as seen in \autoref{fig:wasmmodules}.
Functions, globals, the table, and memory can be imported, using $\<import> "name_1"\; "name_2"$, which imports $name_2$ from the file $name_1$.
Similarly, they can also be exported under any number of names using $\<export> "name"$.

Functions include a list of local variable declarations to use within the body (a sequence of instructions).
Additionally, function arguments are accessible as local variables within the body of functions.
Global variables may be mutable (although, exported global variables cannot be mutable, as we will see later), and are initialized via a sequence of instructions.
Function tables store references to functions that can be called using indirect function calls, they are used to more safely represent function pointers.
Indirect function calls must supply a function type that gets checked against the table function that ends up being called at run-time.
Linear memory is simply a very large continuous chunk of memory.
Memory load and store operations require run-time bounds checks to ensure that they operate within the chunk of memory.

\begin{figure}
    \begin{math}
    \begin{array}{rcl}
        im &::=& \<import> "name_1"\; "name_2" \\
        ex &::=& \<export> "name" \\
        f &::=& ex^{*}\; \<func> tf\; \<local>\; t^{*}\; e^{*} \mid ex^{*}\; \<func> tf\; im \\
        glob &::=& ex^{*}\; \<global> tg\; e^{*} \mid ex^{*}\; \<global> tg\; im \\
        tab &::=& ex^{*}\; \<table> n\; i^{*} \mid ex^{*}\; \<table> n\; im \\
        mem &::=& ex^{*}\; \<memory> n\; \mid ex^{*}\; \<memory> n\; im \\
        module &::=& \<module> f^{*}\; glob^{*}\; tab^{?}\; mem^{?}
    \end{array}
    \end{math}
    \caption{\wasm Module Definitions}
    \label{fig:wasmmodules}
\end{figure}


\subsection{\wasm Semantics}
\label{subsec:wasmsemantics}
\wasm is a stack-based assembly language that uses a mixed reduction and small-step operational semantics.
The ``stack'' is actually just the sequence of values preceding the first reducible instruction.
Instructions are reduced in place by decomposing the entire program using reduction contexts.
Reduction contexts are based on label blocks, administrative instructions used to handle control flow.
Branching from inside a label block essentially peels back the specified number of label blocks, and continues executing with the stored instructions (used only by loops which store the loop code) of the containing label block.
For example, $\<label> \{\} \<label> \{\} \<label> \{\} \<br> 1 \<end> \<end> \<end>$ will reduce to $\<label> \{\} \<end>$, while $\<label> \{ \<loop> ... \<end> \} \<br> 1 \<end>$ reduces to $\<loop> ... \<end>$.

\subsection{The \wasm Type System}
\label{subsec:wasmtyping}
\wasm is a stack-based language, so the type of an instruction in \wasm consists of a precondition and postcondition on the shape of the stack.
This can be viewed as though instructions \emph{consume} certain values from the stack and then \emph{produce} values to be pushed on the stack.
For example, a binary operation of some type $t$ consumes two values of the given type $t$ on the stack and produces a value of type $t$:

\[
    \inferrule{ }{C \vdash t.binop : t\; t \rightarrow t}
\]

The above example shows what a typical \wasm typing rule looks like.
$C$ is the module type context, which keeps track of various module-level types: functions, globals, the table, memory, locals, the label stack (\ie the expected types for branching instructions), and the return stack (\ie the expected type of the return instruction).
The type associated with the instruction $t.binop$ is a \wasm function type, which is just the precondition (on the left of the $\rightarrow$) and postcondition (on the right of the $\rightarrow$) on the stack.

\paragraph{Stack Polymorphism.}
To compose together the types of many instructions, it is necessary to carry around extra type information about the rest of the stack while type-checking instructions.
\emph{Stack polymorphism} allows extending the precondition and postcondition with the same data to thread unmodified parts of the stack through a list of instructions.
Intuitively, this allows you to ``forget'' the rest of the stack and focus only on the part being manipulated by the instruction being checked, after which point the ``forgotten'' part can be re-added.

For example, if the stack has the shape $\<isixfour>\; \<ithreetwo>\; \<ithreetwo>$, then stack polymorphism allows us to ignore $\<isixfour>$ and typecheck $\<ithreetwo>.binop$ with $\<ithreetwo>\;\<ithreetwo>$.
Then the stack would look like $\<ithreetwo>$, at which point we add $\<isixfour>$ back to the postcondtion to get $\<isixfour>\; \<ithreetwo>$ after executing $\<ithreetwo>.binop$.
