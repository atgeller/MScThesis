\chapter{Implementation}
To ensure the feasibility of implementing the \name language we implemented a reference interpreter in Redex \cite{redex}.
We were able to handle the entirety of the type system and use the reference interpreter to typecheck several test programs, including test programs using \prechk-tagged instructions.
Further, our reference interpreter is able to implement constraint solving and implication.

\section{Reference Interpreter}
We developed the formal model of \name by creating a machine model in Redex of \wasm and extending it with the \name syntax and type system.
This ensured that our model worked silicon and not just set theory, and made it possible to quickly test out various approaches.
The syntatic representation we used in the redex model differs a bit, as it is s-expression based and doesn't support the various annotations that are used in a formal model on paper.

We implemented the static typing judgment $(\vdash C\; (e\;...)\; tfi)$, where $e ...$ is Redex for $e^{*}$.
Here is \refrule{Const} in Redex.
Note that it is essentially the same, minus a few syntactic differences.
\begin{lstlisting}[escapeinside={(*}{*)}]
    [((*$\vdash$*) C ((t const c))
            ((() l (*$\phi$*))
             (*$\rightarrow$*) (((t a)) l (((*$\phi$*) (t a)) (= a (t c))))))]
\end{lstlisting}
There is an extra set of parentheses around $(t\;const\;c)$ because the judgment works over sequences of instructions $(e\;...)$, where $e\;... = (t\;const\;c)$ here.
Also, there's no dot between the type $t$ and the constant instruction keyword $const$ because that is not a special symbol in Redex.

Because the \name type system is bi-directional (rules such as \refrule{Const} infer types, whereas \refrule{Block} checks against an expected type), we only have a typechecker in the Redex model.
Thus, we must manually construct derivations and ask if they are valid.

\section{Constraint Solving in Practice}
In our interpreter, we reason about constraints using the Z3 theorem prover \cite{z3}.
To test whether the satisfiability of one index type context $\phi_1$ implies that some other index type context $\phi_2$ is satisfiable, we first generate Z3 constraints based on the propositions in both contexts.
Then, we assert that the constraints generated for the first context must hold.
Finally, we ask Z3 to find an assignment to the variables declared in the type index contexts where the constraints from the second context do not hold (a counterexample).
If a counterexample cannot be found then the implication must hold, otherwise it does not hold.

\subsection{Impact of using Z3.}
Our choice of using Z3 has impacted \name in several ways.

\paragraph{Floating point values and operations}
We currently do not supporting floating point values because Z3 is unable to reason about them.
In addition, the \wasm unary operators ($ctz$, $clz$, and $popcnt$, which provide bit-level information) and certain binary operators ($rotr$ and $rotl$) would be difficult and inefficient to reason about using Z3 due to their non-linearity, so we do not currently support them in \name.

\paragraph{Type annotations in constraints.}
The requirement of adding explicit type annotations for index variables and constants that appear in type indices comes from needing to know what width the variable will be when we convert it to a Z3 bitvector.
Z3 bitvectors are fixed-width bitvectors that Z3 can reason about using standard operations (addition, multiplication, shift left, etc...).
\name integers are also fixed width, so this is an exact reprsentation within Z3.
Further, fixed-width bitvectors are a finite domain that has more efficient reasoning and decidability compared to the natural numbers.

\paragraph{Performance concerns.}
There are performance concerns when using an SMT solver.
While our small examples programs have been near instantaneous to typecheck, we may see slowdown due to significantly larger constraint sets when typechecking large \wasm programs.
This would require a clever approach to reducing the size of the constraint set (perhaps using a form of type-level garbage collection on constraints on index variables that cannot be referred to).
Also, we would want to make sure when writing a type checker/synthesizer that we invoke Z3 as little as possible, by minimizing the amount of reasoning we do about the constraints.