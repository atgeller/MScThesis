\chapter{Metatheory}
\label{chp:metatheory}

Now that we have introduced \name and shown how it can be used for reasoning, it is time to reason about \name itself.
First, we will take a look at the relationship between \wasm and \name, by showing methods to convert \wasm programs to \name programs and vice versa.
Then, we will prove the type safety of \name, to ensure that our claim that \name is as safe as \wasm is valid.
However, before we can do any of that, we must ``complete'' our reasoning ability by creating a way to connect the reduction relation form with the type system.

\section{Administrative Typing Rules}
While we have shown the \name typing rules for instructions within a static context, we still need typing rules for administrative instructions and the store used in reduction.
\autoref{fig:programrules} shows the \name typing rules for module instances $inst$, the run time store $s$, and various data structures contained within $s$.
$S$ is the store context, it is to $s$ as $C$ is to $inst$.
That is, it contains the type information for everything in $s$.
There are many different judgments being introduced, so we explicitly state the form of the judgment before stating the rule for that judgment.

Closures are type checked by \refrule{Closure}, which falls back on the module typing rules \autoref{fig:modulerules} to type check the function definition inside of the closure.
\refrule{Admin-Const} gets the postcondition indexed types and constraints on values, it is used to type check local and global variables.

\refrule{Instance} checks that a module instance is well-typed by the index module context under the store context $S$.
It checks all of the closures $cl^{*}$ against their expected types $tfi^{*}$ in $C$, and similarly for all of the globals ($v^{*}$ and $()\text{mut}^{?} t)^{*}$).
The table and memory indices ($i$ and $j$, respectively) are used to lookup the the relevant types ($(n,tfi^{*})$ and $m$, respectively) in the store context $S$.

\refrule{Store} uses \refrule{Instance} to check that a run time store, $s$ is well typed by the store context $S$ by ensuring that every module instance $inst$ in $s$ has the type of the index module context $C$ in $S$
Further, \refrule{Store} ensures that all of the closures in all of the tables in $s$ are well typed, and the the sizes of all the tables and memory chunks in $S$ do not exceed the actual size of their implementations.

\begin{figure}
    \begin{mathpar}
        \boxed{S \vdash cl : tfi} \\

        \inferrule*[right=\defrule{Closure}]{ %% closure
            S_\text{inst}(i) \vdash f : tfi
        } {
            S \vdash \{ \text{inst} \; i, \text{code} \; f \} : tfi
        }

        \\ \boxed{\vdash v : ti;\phi} \\

        \inferrule*[right=\defrule{Admin-Const}]{ %% admin const
        } {
            \vdash t.\<const> c : \ti{t}{a};\circ,\ti{t}{a},(\<eq> a \; \ti{t}{c})
        }

        \\ \boxed{S \vdash inst : C} \\

        \inferrule*[right=\defrule{Instance}]{ %% instance
            (S \vdash cl : tfi)^{*} \and
            (\vdash v : \ti{t}{a},\phi_v)^{*} \\
            (S_\text{tab}(i) = n)^{?} \and
            (S_\text{mem}(j) = m)^{?}
        } {
            S \vdash
            {\begin{stackTL}
                \{ \text{func} \; cl^{*}, \text{glob} \; v^{*}, \text{tab} \; i^{?}, \text{mem} \; j^{?} \}
                \\ : \{ \text{func} \; tfi^{*}, \text{global} \; (\text{mut}^{?} \; t)^{*}, \text{table} \; n^{?}, \text{memory} \; m^{?} \}
            \end{stackTL}}
        }

        \\ \boxed{\vdash s : S} \\

        \inferrule*[right=\defrule{Store}]{ %% store
            S = \{ \text{inst} \; C^{*}, \text{tab} \; n^{*}, \text{mem} \; m^{*} \}\\
            (S \vdash inst : C)^{*} \and
            ((S \vdash cl : tfi)^{*})^{*} \and
            (n \leq |cl^{*}|)^{*} \and
            (m \leq |b^{*}|)^{*}
        } {
            \vdash \{ \text{inst} \; inst^{*}, \text{tab} \; (cl^{*})^{*}, \text{mem} \; (b^{*})^{*} \} : S
        }

        \\ \boxed{S;(ti^{*};l;\phi)^{?} \vdash_i v^{*};e^{*} : ti^{*};l;\phi} \\

        \inferrule*[right=\defrule{Code}]{ %% admin code
            (\vdash v : \ti{t}{a};\phi_v)^{*}\\
            C = S_{\text{inst}}(i),\text{local} \; t^{*}, \text{return} \; (ti^n;l;\phi)^{?}\\
            S;C \vdash e^{*} : \epsilon:\ti{t}{a}^{*};\phi_v^{*} \rightarrow ti^n;l;\phi
        } {
            S;(ti^n;l;\phi)^{?} \vdash_i v^{*};e^{*} : ti^n;l;\phi
        }

        \boxed{\vdash s;v^{*};e^{*}} \\

        \inferrule*[right=\defrule{Program}]{ %% admin program
            \vdash s : S \and
            S;\epsilon \vdash_i v^{*};e^{*} : ti^{*};l;\phi
        } {
            \vdash_i s;v^{*};e^{*} : ti^{*};l;\phi
        }
    \end{mathpar}
    \caption{\protect\name Program and Store Typing Rules}
    \label{fig:programrules}
\end{figure}

Further, we must provide a typing rule that has the same form as the reduction relation (\ie a typing rule for $s;v;e$) to be able to get the type of a program during reduction.

\refrule{Code} checks that a sequence of instructions is well typed with an empty stack and the indexed types and constraints for the given local variables in the precondition.
Since local variables are values, we know that each one of them is equal to some constant, so \refrule{Code} is really just checking that the sequence of instructions has some postcondition reachable from the given local variables.
There is an optional return postcondition for \refrule{Code} because \refrule{Local} has as a premise a judgment of the exactly same form, except with a return postcondition.
\refrule{Program} uses \refrule{Code} without using the optional return postcondition, as well as \refrule{Store}, to ensure that a reducible \name program is well-typed.

\begin{figure}
    $$\boxed{S;C \vdash e^{*} : tfi}$$

    \begin{mathpar}
        \inferrule*[right=\defrule{Local}]{ %% local
            S;(ti^n;l_2;\phi_2) \vdash_i v_l^{*};e^{*} : ti^n;l_2;\phi_2
        } {
            S;C \vdash \<local> \{ i;v_l^{*} \} \; e^{*} \<end> : \epsilon;l_1;\phi_1 \rightarrow ti^n;l_1;\phi_1,\phi_2
        }

        \inferrule*[right=\defrule{Call-Cl}]{ %% call closure
            S \vdash cl : tfi
        } {
            S;C \vdash \<call> cl : tfi
        }

        \inferrule*[right=\defrule{Trap}]{ %% trap
        } {
            S;C \vdash \<trap> : tfi
        }

        \inferrule*[right=\defrule{Label}]{ %% label
            S;C\vdash e_0^{*} : ti_3^{*};l_3;\phi_3 \rightarrow ti_2^{*};l_2;\phi_2 \\
            S;C,\text{label } (ti_3^{*};l_3;\phi_3) \vdash e^{*} : \epsilon;l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2
        } {
            S;C \vdash \<label> \{ e_0^{*} \} \; e^{*} \<end> : \epsilon;l_1;\phi_1 \rightarrow ti_2^{*};l_2;\phi_2
        }
    \end{mathpar}
    \caption{\name Administrative Instruction Rules}
    \label{fig:adminrules}
\end{figure}

\autoref{fig:adminrules} extends the \name typing rules for instructions to include administrative instructions.
\refrule{Local} typechecks the local block using \refrule{Code} to ensure that the body is well typed with the indexed types and constraints for local variables provided by the local block as the precondition and any postcondition.
Since local blocks are inline expansions of function calls, we use the optional return postcondition functionality of \refrule{Code} to ensure that returning from inside the local block will be well-typed.

\refrule{Call-Cl} typechecks calling a closure by ensuring that the closure being called has the same type as the call instruction.
\refrule{Trap} is always well-typed under any precondition and postcondition.

\refrule{Label} typechecks the body of the label block with the precondition of the saved instructions pushed onto the label stack.
This was, if the label was generated by a loop, then the precondition of the saved values is the precondition of the loop, and we know the loop is well-typed.
Otherwise, the saved instructions will be an empty sequence and will be well typed from the precondition.

Additionally, we must keep track of the store context $S$ in all of the other typing rules.
We do this by ``silently'' adding $S$ to the typing judgment and rules in \autoref{sec:typesys}.

Given these additional typing judgments and rules, we can now show the metatheoretic properties mentioned above.

\section{Relationship Between \wasm and \name}
We want to show two properties about the relationship between \wasm and \name.
First, we want \name to be backwards compatible with \wasm.
It should be possible to convert well-typed \wasm programs into well-typed \name programs with no additional developer effort.
We demonstrate a simple yet naive way of embedding \wasm programs into \name in \autoref{subsec:embedding}.
Second, we want to show that well-typed \name programs can be turned into \wasm programs.
This is accomplished in \autoref{subsec:erasure} using an erasure function that turns \name programs and types into \wasm programs and types.

\input{Chapters/MetaTheory/embedding.tex}
\input{Chapters/MetaTheory/erasure.tex}

\section{Type Safety}
\label{sec:typesafety}
\emph{Type safety} is the property that a well-typed program either reduces to another well-typed program, is an irreducible expression (in the case of \name, a sequence of values), or throws an error (trap, in the case of \name).
Thus, type safety assures us that the behavior of a well-typed program is always well-defined.
The type safety of \wasm guarantees a number of important properties, including memory safety.
Proving the type safety of \name gives us a high degree of assurance that it has the same level of safety as \wasm.

\input{Chapters/MetaTheory/subject-reduction.tex}
\input{Chapters/MetaTheory/progress.tex}
