\chapter{Introduction}
\label{chp:intro}

Types systems are useful for reasoning about programs.
They can be used to reason about the correctness of programs, usually in the form of safety guarantees.
For example, type safety is the property that a well-typed program will never become \emph{stuck}, that is, it will always be able to reduce the current expression or the current expression is a well-formed irreducible value.
The safety guarantees of type systems provide a degree of trust in programs as a well typed program implicitly contains a checkable proof that it will not exhibit behavior disallowed by the type system.

More expressive type systems that can encode richer invariants, can allow near complete trust in a program by verifying that it will never exhibit unsafe behavior.
Generally, such type systems are attached to high-level languages, where explicit abstractions make it easy to reason about programs.
Conversely, using expressive type systems in low-level languages often requires reasoning about program state, which introduces more complexity into the type system.
However, prior work has attached expressive type systems, that permit complex correctness guarantees, to simple low-level languages.

Using such an expressive type system for a low-level language, we can alleviate overhead otherwise required to ensure safety of untrusted low-level programs.
Typically, executing code in an untrusted context requires dynamic safety checks which introduce potentially unnecessary instructions, slowing down execution.
However, with the safety guarantees provided by the type system, we can determine when these checks are unnecessary and remove them.
This would allow low-level programs to be downloaded, checked, and executed safely and efficiently.

Browsers and Internet-of-Things (IoT) require running untrusted code, that may have been downloaded from anywhere.
It is crucial to ensure the safety of the code being executed.
Typically this is accomplished using dynamic safety checks and sandboxing, but dynamic safety checks introduce potentially unnecessary instructions, slowing down code.
\todo{Introduce WebAssembly}

Type systems can be used to alleviate the need for safety checks, reducing overhead, by providing safety guarantees about programs before they are run.
The idea of using type systems to ensure the safety of low-level code is not a new one.
Several projects have attached expressive type systems to low-level languages to attach proofs of correctness to low-level programs.
However, the focus in these cases is on correctness, not on performance.
Using a more expressive type system, we can ensure safety \emph{and} improve the performance of low-level code in untrusted environments.

\section{Contributions}
We want to use types to improve performance while ensuring safety in real-world low-level programs.
Towards that goal, we have created a indexed type system, \name, for WebAssembly (\wasm) which guarantees safety and has the potential to improve performance.
\thought{Only one sentence of justification? It's a good sentence but it doesn't capture the entire argument behind \wasm. Also, this really doesn't belong in the contributions part.}
We chose \wasm because it is used in browsers and IoT devices, so both performance and safety are critical concerns.

\todo{This is weak}
\name is an index type system which is able to encode linear constraints on program variables.
These constraints provide sufficient information to tell if dynamic checks are unnecessary for a given operation.

\section{Roadmap}
\todo{I don't think this is needed with combined technical sections}
Chapter 2 discusses related work to provide background and highlight the contributions of our work.
In chapter 3, we present the \name index type system and explain how it works.
Chapter 4 explains how we facilitate dynamic check elimination using \name.
To ensure safety, we prove the type safety of \name in Chapter 5.
Chapter 6 offers a discussion of our results.
Finally, Chapter 7 concludes the thesis.
